import printer.(println);
import test.memory.(Canary, checkCanariesDestroyed);

// test that default assign(ref, ref) implementation works with a type defining
// a throwing or nonthrowing copy constructor

record NonthrowingCopy (c:Canary);
override RegularRecord?(#NonthrowingCopy) = false;
override CopyDoesNotThrowType?(#NonthrowingCopy) = true;
override NonthrowingCopy() = initializeRecord(NonthrowingCopy);
override NonthrowingCopy(x:NonthrowingCopy) = copyRecord(x);
override moveUnsafe(x:NonthrowingCopy) = moveRecordUnsafe(x);
override resetUnsafe(x:NonthrowingCopy) { resetRecordUnsafe(x); }
override destroy(x:NonthrowingCopy) { destroyRecord(x); }

record ThrowingCopy (c:Canary);
override RegularRecord?(#ThrowingCopy) = false;
override CopyDoesNotThrowType?(#ThrowingCopy) = false;
override ThrowingCopy() = initializeRecord(ThrowingCopy, Canary(true));
override ThrowingCopy(throw?) = initializeRecord(ThrowingCopy, Canary(throw?));
override ThrowingCopy(x:ThrowingCopy) = copyRecord(x);
override moveUnsafe(x:ThrowingCopy) = moveRecordUnsafe(x);
override resetUnsafe(x:ThrowingCopy) { resetRecordUnsafe(x); }
override destroy(x:ThrowingCopy) { destroyRecord(x); }

tryNonthrowing() {
    var a = NonthrowingCopy();
    var b = NonthrowingCopy();
    a = b;
    var c = move(a);
    c = move(b);
}

tryThrowing() {
    var a = ThrowingCopy(true);
    var b = ThrowingCopy(true);
    try {
        a = b;
    } catch (ex) {}
    var c = move(a);
    c = move(b);

    var d = ThrowingCopy(false);
    c = d;
}

main() {
    tryNonthrowing();
    tryThrowing();
    if (checkCanariesDestroyed())
        println("ok");
}
