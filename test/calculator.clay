
import parsing.combinators.*;
import maybe.*;

//
// bracketed -> '(' expr ')'
// number -> digit+
// factor -> number | bracketed
//
// term -> factor (('*' | '/') factor)*;
//
// expr -> term (('+' | '-') term)*
//

expr(input) Maybe[Int] = expr2(input);

var bracketed = modify(x => x.1, ('(', expr, ')'));
var digit = condition(c => ((c >= '0') and (c <= '9')));
var number = modify(Int, oneOrMore(digit));
var factor = choice(number, bracketed);
var term = modify(foldTail, (factor, zeroOrMore((choice('*', '/'), factor))));
var expr2 = modify(foldTail, (term, zeroOrMore((choice('+','-'), term))));

foldTail(x) {
    var result = x.0;
    for (y in x.1) {
        switch (y.0) {
            case '+' : result += y.1; break;
            case '-' : result -= y.1; break;
            case '*' : result *= y.1; break;
            case '/' : result /= y.1; break;
            default : assert(false); break;
        }
    }
    return result;
}

calculate(s) {
    var input = iterator(s);
    var result = expr(input);
    print(s, " = ", result);
    var unparsed = String(input);
    if (not empty?(unparsed))
        print(" (unparsed: '", unparsed, "')");
    println();
}

private DefaultIterator(Token) = Type(iterator(typeToLValue(Vector[Token])));

main() {
    ref args = commandLine();
    if (size(args) != 2) {
        println("usage: ", args[0], " <expr>");
        return -1;
    }
    calculate(args[1]);
    return 0;
}
