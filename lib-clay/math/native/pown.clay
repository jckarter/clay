// pow x^n | Type(n)==Integer
// pow n^m | Type(n,m)==Integer

//public import math.native.defines.(pow);
import math.*;

[T,I | Float?(T) and Integer?(I)]
overload pow(x:T, n:I) {
    alias ZERO = T(0);
    alias ONE = T(1);
    var p,v,m = ONE, ZERO, n;
    if (n < 0) {
        switch (n)
        case (-1) return ONE / x;
        case (-2) return ONE / (x * x);
        m = -n;
        v = ONE / x;
    }
    else {
        switch (n)
        case (0) return ONE;
        case (1) return x;
        case (2) return x * x;
        v = x;
    }

    while (true) {
        if (bitand(m,1)!=0)
            p *= v;
        m = bitshr(m,1);
        if (m==0) break;
        v *= v;
    }
    return p;
}

[I,J | Integer?(I,J)]
overload pow(x:I, n:J) {
    alias ZERO = I(0);
    alias ONE = I(1);
    if (n < ZERO) return x \ ZERO; // Only support positive powers
    var p, v = ONE, ZERO;
    var m = n;

    switch (m)
    case (0) p = ONE;
    case (1) p = x;
    case (2) p = x * x;
    else {
        v = x;
        while (true){
            if (bitand(m,ONE)!=ZERO)
                p *= v;
            m = bitshr(m,ONE);
            if (m==ZERO) break;
            v *= v;
        }
    }
    return p;
}