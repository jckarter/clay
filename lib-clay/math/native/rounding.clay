
import math.native.kernel.ieee754.*;
import math.*;

private alias DHUGE = GreatestPositiveFinite(Double);
private alias FHUGE = GreatestPositiveFinite(Float);
private alias DZERO = 0.ff;
private alias FZERO = 0.f;

[T when Float?(T)]
overload round(x:T) --> t:T {
	alias ZERO = T(0);
	alias MHALF = T(-0.5);
	alias ONE = T(1);
	
	if (not finite?(x))
		return (x);

	if (x >= ZERO) {
		t <-- floor(x);
		if (t - x <= MHALF)
			t +: ONE;
	} else {
		t <-- floor(-x);
		if (t + x <= MHALF)
			t +: ONE;
		t = -t;
	}
}



private var TWO52 = array(
  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
 -4.50359962737049600000e+15 /* 0xC3300000, 0x00000000 */
);

overload rint(a:Double){
	var x = a;
	var ix = MAKE_IEEE(x);
	var sx = bitand(bitshr(GET_IEEE_HIGH(ix),31),0x1);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) {
			if(bitor(bitand(GET_IEEE_HIGH(ix),0x7fffffff),GET_IEEE_LOW(ix))==0) return x;
			SET_IEEE_LOW(ix,bitor(GET_IEEE_LOW(ix),bitand(GET_IEEE_HIGH(ix),0x0fffff)));
			SET_IEEE_HIGH(ix,bitand(GET_IEEE_HIGH(ix),bitcast(Int32,0xfffe0000u)));
			SET_IEEE_HIGH(ix,bitor(GET_IEEE_HIGH(ix),bitand(bitshr(bitor(GET_IEEE_LOW(ix),-GET_IEEE_LOW(ix)),12),0x80000)));
			x = SET_IEEE_HIGH(x,GET_IEEE_HIGH(ix));
		    var w = TWO52[sx]+x;
		    var t = w-TWO52[sx];
			SET_IEEE_HIGH(ix,GET_IEEE_HIGH(t));
			t = SET_IEEE_HIGH(t,bitor(bitand(GET_IEEE_HIGH(ix),0x7fffffff),bitshl(sx,31)));
		    return t;
	    } 
	    else {
			var i = bitshr(0x000fffff,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			i = bitshr(i,1);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))!=0) {
			    /*
			     * Some bit is set after the 0.5 bit.  To avoid the
			     * possibility of errors from double rounding in
			     * w = TWO52[sx]+x, adjust the 0.25 bit to a lower
			     * guard bit.  We do this for all j0<=51.  The
			     * adjustment is trickiest for j0==18 and j0==19
			     * since then it spans the word boundary.
			     */
			    if(j0==19) SET_IEEE_LOW(ix,0x40000000); else
			    if(j0==18) SET_IEEE_LOW(ix,bitcast(Int32,0x80000000u)); else
			    SET_IEEE_HIGH(ix,bitor(bitandc(GET_IEEE_HIGH(ix),i),bitshr(0x20000,j0)));
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(0xffffffffu,j0-20);
	    if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    i = bitshr(i,1);
	    if(bitand(GET_IEEE_LOW(ix),i)!=0) 
	    	SET_IEEE_LOW(ix,bitcast(Int32,bitor(bitandc(GET_IEEE_LOW(ix),i),bitshr(0x40000000,j0-20))));
	}
	var w = TWO52[sx]+GET_IEEE_DB(ix);
	return w-TWO52[sx];
}

overload floor(x:Double) {
	var ix = MAKE_IEEE(x);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
		if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
		    if(GET_IEEE_HIGH(ix)>=0)
		    	SET_IEEE(ix,0l);
		    else 
		    	if(bitor(bitand(GET_IEEE_HIGH(ix),0x7fffffff),GET_IEEE_LOW(ix))!=0) { 
					SET_IEEE_HIGH(ix,bitcast(Int32,0xbff00000u));
					SET_IEEE_LOW(ix,0);
				}
		}
	    } 
	    else {
			var i = bitshr(0x000fffff,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(GET_IEEE_HIGH(ix)<0) GET_IEEE_HIGH(ix) +: bitshr(0x00100000,j0);
			    SET_IEEE_HIGH(ix,bitandc(GET_IEEE_HIGH(ix),i));
			    SET_IEEE_LOW(ix,0);
			}
	    }
	} else 
		if (j0>51) {
	    	if(j0==0x400) return x+x;	/* inf or NaN */
	    	else return x;		/* x is integral */
		} 
		else {
	    	var i = bitshr(0xffffffffu,j0-20);
	    	if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    	if(DHUGE+x>DZERO) { 		/* raise inexact flag */
				if(GET_IEEE_HIGH(ix)<0) {
			    	if(j0==20) GET_IEEE_HIGH(ix)+:1;
		    		else {
						var j = GET_IEEE_LOW(ix)+bitshl(1,(52-j0));
						if(j<GET_IEEE_LOW(ix)) GET_IEEE_HIGH(ix) +:1 ; 	/* got a carry */
						SET_IEEE_LOW(ix,j);
		    		}
				}
			SET_IEEE_LOW(ix,bitcast(Int32,bitandc(GET_IEEE_LOW(ix),i)));
	    	}
		}
	return GET_IEEE_DB(ix);
}

overload floor(x:Float){
	var ix = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(ix,23),0xff)-0x7f;
	if(j0<23) {
	    if(j0<0) 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) /* return 0*sign(x) if |x|<1 */
			    if(ix>=0)
			    	ix=0;
			    else 
			    	if(bitand(ix,0x7fffffff)!=0)
			    		ix = bitcast(Int,0xbf800000u);
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(ix,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(ix<0) ix +: bitshr(0x00800000,j0);
			    ix = bitandc(ix,i);
			}
	    }
	} 
	else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(ix);
}

overload ceil(x:Double) {
	var ix = MAKE_IEEE(x);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
			if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
			    if(GET_IEEE_HIGH(ix)<0) {
			    	SET_IEEE_HIGH(ix,bitcast(Int32,0x80000000u));
			    	SET_IEEE_LOW(ix,0);
			    }
			    else 
			    	if(bitor(GET_IEEE_HIGH(ix),GET_IEEE_LOW(ix))!=0) { 
			    		SET_IEEE_HIGH(ix,0x3ff00000);
			    		SET_IEEE_LOW(ix,0);
			    	}
			}
	    } 
	    else {
			var i = bitshr(0x000fffff,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(GET_IEEE_HIGH(ix)>0) GET_IEEE_HIGH(ix) +: bitshr(0x00100000,j0);
			    SET_IEEE_HIGH(ix, bitandc(GET_IEEE_HIGH(ix),i)); 
			    SET_IEEE_LOW(ix, 0);
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400u) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(0xffffffffu,j0-20);
	    if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    if(DHUGE+x>DZERO) { 		/* raise inexact flag */
			if(GET_IEEE_HIGH(ix)>0) {
			    if(j0==20) GET_IEEE_HIGH(ix)+:1;
			    else {
					var j = GET_IEEE_LOW(ix) + bitshl(1,52-j0);
					if(j<GET_IEEE_LOW(ix)) GET_IEEE_HIGH(ix)+:1;	/* got a carry */
					SET_IEEE_LOW(ix, j);
			    }
			}
			SET_IEEE_LOW(ix, bitcast(Int32,bitandc(GET_IEEE_LOW(ix),i)));
	    }
	}
	return GET_IEEE_DB(ix);
}

overload ceil(x:Float) {
	var ix = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(ix,23),0xff)-0x7f;
	if(j0 < 23) {
	    if(j0 < 0) { 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) {/* return 0*sign(x) if |x|<1 */
			    if(ix<0) ix=bitcast(Int,0x80000000u);
			    else if(ix!=0) ix=0x3f800000;
			}
	    } 
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(ix,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(ix>0) ix +: bitshr(0x00800000,j0);
			    ix = bitandc(ix,i);
			}
	    }
	} else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(ix);
}
