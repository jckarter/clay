
import math.native.kernel.ieee754.*;
//public import math.native.defines.(round,floor,ceil,rint);
//import numbers.floats.(finite?);
import math.*;

private alias DHUGE = GreatestPositiveFinite(Double);
private alias FHUGE = GreatestPositiveFinite(Float);
private alias DZERO = 0.ff;
private alias FZERO = 0.f;

[T | Float?(T)]
overload round(x:T) --> t:T {
	alias ZERO = T(0);
	alias MHALF = T(-0.5);
	alias ONE = T(1);
	
	if (not finite?(x))
		return (x);

	if (x >= ZERO) {
		t <-- floor(x);
		if (t - x <= MHALF)
			t += ONE;
	} else {
		t <-- floor(-x);
		if (t + x <= MHALF)
			t += ONE;
		t = -t;
	}
}



private var TWO52 = array(
  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
 -4.50359962737049600000e+15 /* 0xC3300000, 0x00000000 */
);

overload rint(a:Double){
	var x = a;
	var ix = MAKE_IEEE(x);
	var sx = bitand(bitshr(GET_IEEE_HIGH(ix),31),0x1);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) {
			if(bitor(bitand(GET_IEEE_HIGH(ix),MM),GET_IEEE_LOW(ix))==0) return x;
			GET_IEEE_LOW(ix) = bitor(GET_IEEE_LOW(ix),bitand(GET_IEEE_HIGH(ix),0x0fffff));
			GET_IEEE_HIGH(ix) = bitand(GET_IEEE_HIGH(ix),bitcast(Int32,0xfffe0000u));
			GET_IEEE_HIGH(ix) = bitor(GET_IEEE_HIGH(ix),bitand(bitshr(bitor(GET_IEEE_LOW(ix),-GET_IEEE_LOW(ix)),12),0x80000));
			x = SET_IEEE_HIGH(x,GET_IEEE_HIGH(ix));
		    var w = TWO52[sx]+x;
		    var t = w-TWO52[sx];
			GET_IEEE_HIGH(ix) = GET_IEEE_HIGH(t);
			t = SET_IEEE_HIGH(t,bitor(bitand(GET_IEEE_HIGH(ix),MM),bitshl(sx,31)));
		    return t;
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			i = bitshr(i,1);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))!=0) {
			    /*
			     * Some bit is set after the 0.5 bit.  To avoid the
			     * possibility of errors from double rounding in
			     * w = TWO52[sx]+x, adjust the 0.25 bit to a lower
			     * guard bit.  We do this for all j0<=51.  The
			     * adjustment is trickiest for j0==18 and j0==19
			     * since then it spans the word boundary.
			     */
			    if(j0==19) GET_IEEE_LOW(ix) = CV2; else
			    if(j0==18) GET_IEEE_LOW(ix) = SM; else
			    GET_IEEE_HIGH(ix) = bitor(bitandc(GET_IEEE_HIGH(ix),i),bitshr(0x20000,j0));
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(AM,j0-20);
	    if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    i = bitshr(i,1);
	    if(bitand(GET_IEEE_LOW(ix),i)!=0) GET_IEEE_LOW(ix) = bitor(bitandc(GET_IEEE_LOW(ix),i),bitshr(CV2,j0-20));
	}
	var w = TWO52[sx]+GET_IEEE_DB(ix);
	return w-TWO52[sx];
}

overload floor(x:Double) {
	var ix = MAKE_IEEE(x);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
		if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
		    if(GET_IEEE_HIGH(ix)>=0) {
		    	GET_IEEE_HIGH(ix)=0;
		    	GET_IEEE_LOW(ix)=0;
		    }
		    else 
		    	if(bitor(bitand(GET_IEEE_HIGH(ix),MM),GET_IEEE_LOW(ix))!=0) { 
					GET_IEEE_HIGH(ix)=CV21;
					GET_IEEE_LOW(ix)=0;
				}
		}
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(GET_IEEE_HIGH(ix)<0) GET_IEEE_HIGH(ix) += bitshr(CV8,j0);
			    GET_IEEE_HIGH(ix) = bitandc(GET_IEEE_HIGH(ix),i);
			    GET_IEEE_LOW(ix) = 0;
			}
	    }
	} else 
		if (j0>51) {
	    	if(j0==0x400) return x+x;	/* inf or NaN */
	    	else return x;		/* x is integral */
		} 
		else {
	    	var i = bitshr(AM,j0-20);
	    	if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    	if(DHUGE+x>DZERO) { 		/* raise inexact flag */
				if(GET_IEEE_HIGH(ix)<0) {
			    	if(j0==20) GET_IEEE_HIGH(ix)+=1;
		    		else {
						var j = GET_IEEE_LOW(ix)+bitshl(1,(52-j0));
						if(j<GET_IEEE_LOW(ix)) GET_IEEE_HIGH(ix) +=1 ; 	/* got a carry */
						GET_IEEE_LOW(ix)=j;
		    		}
				}
			GET_IEEE_LOW(ix) = bitandc(GET_IEEE_LOW(ix),i);
	    	}
		}
	return GET_IEEE_DB(ix);
}

overload floor(x:Float){
	var ix = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(ix,23),0xff)-0x7f;
	if(j0<23) {
	    if(j0<0) 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) /* return 0*sign(x) if |x|<1 */
			    if(ix>=0)
			    	ix=0;
			    else 
			    	if(bitand(ix,0x7fffffff)!=0)
			    		ix = bitcast(Int,0xbf800000u);
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(ix,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(ix<0) ix += bitshr(0x00800000,j0);
			    ix = bitandc(ix,i);
			}
	    }
	} 
	else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(ix);
}

overload ceil(x:Double) {
	var ix = MAKE_IEEE(x);
	var j0 = bitand(bitshr(GET_IEEE_HIGH(ix),20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
			if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
			    if(GET_IEEE_HIGH(ix)<0) {
			    	GET_IEEE_HIGH(ix)=SM;
			    	GET_IEEE_LOW(ix)=0;
			    }
			    else 
			    	if(bitor(GET_IEEE_HIGH(ix),GET_IEEE_LOW(ix))!=0) { 
			    		GET_IEEE_HIGH(ix)=RM;
			    		GET_IEEE_LOW(ix)=0;
			    	}
			}
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(GET_IEEE_HIGH(ix),i),GET_IEEE_LOW(ix))==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(GET_IEEE_HIGH(ix)>0) GET_IEEE_HIGH(ix) += bitshr(CV8,j0);
			    GET_IEEE_HIGH(ix) = bitandc(GET_IEEE_HIGH(ix),i); 
			    GET_IEEE_LOW(ix) = 0;
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400u) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(AM,j0-20);
	    if(bitand(GET_IEEE_LOW(ix),i)==0) return x;	/* x is integral */
	    if(DHUGE+x>DZERO) { 		/* raise inexact flag */
			if(GET_IEEE_HIGH(ix)>0) {
			    if(j0==20) GET_IEEE_HIGH(ix)+=1;
			    else {
					var j = GET_IEEE_LOW(ix) + bitshl(1,52-j0);
					if(j<GET_IEEE_LOW(ix)) GET_IEEE_HIGH(ix)+=1;	/* got a carry */
					GET_IEEE_LOW(ix) = j;
			    }
			}
			GET_IEEE_LOW(ix) = bitandc(GET_IEEE_LOW(ix),i);
	    }
	}
	return GET_IEEE_DB(ix);
}

overload ceil(x:Float) {
	var ix = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(ix,23),0xff)-0x7f;
	if(j0 < 23) {
	    if(j0 < 0) { 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) {/* return 0*sign(x) if |x|<1 */
			    if(ix<0) ix=bitcast(Int,0x80000000u);
			    else if(ix!=0) ix=0x3f800000;
			}
	    } 
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(ix,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(ix>0) ix += bitshr(0x00800000,j0);
			    ix = bitandc(ix,i);
			}
	    }
	} else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(ix);
}
