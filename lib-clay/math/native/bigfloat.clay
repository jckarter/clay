
import math.native.exact.(db_number);
import numbers.floats.floats.(floatFromBits);

alias SCS_NB_BITS = 30;
alias SCS_NB_WORDS = 8;
alias SCS_MAX_RANGE = 32;
alias SCS_RADIX = UInt(bitshl(1,SCS_NB_BITS));
alias SCS_MASK_RADIX = UInt(SCS_RADIX-1);

record BigFloat (
    /** the digits, as 32 bits words */
    h_word:Array[UInt32,SCS_NB_WORDS],
    /** Used to store Nan,+/-0, Inf, etc and then let the hardware handle them */
    excp:db_number,
    /** This corresponds to the exponent in an FP format, but here we are in base 2^32  */
    index:Int,
    /** The sign equals 1 or -1*/
    sign:Int,
);

var db_one = () -> {var tmp = db_number();tmp.1 = 1l;return tmp;};
var db_zero = () -> {var tmp = db_number();tmp.1 = 0l;return tmp;};

var radix_one_double  = floatFromBits(bitshl(1023ul + SCS_NB_BITS,52));
var radix_two_double  = floatFromBits(bitshl(1023ul + 2*SCS_NB_BITS,52));
var radix_mone_double = floatFromBits(bitshl(1023ul - SCS_NB_BITS,52));
var radix_mtwo_double = floatFromBits(bitshl(1023ul - 2*SCS_NB_BITS,52));
var radix_rng_double  = floatFromBits(bitshl(1023ul + SCS_NB_BITS*SCS_MAX_RANGE,52));
var radix_mrng_double = floatFromBits(bitshl(1023ul - SCS_NB_BITS*SCS_MAX_RANGE,52));
var max_double        = floatFromBits(0x7FEFFFFFFFFFFFFFul);
var min_double        = floatFromBits(0x0000000000000001ul);



//
// constructors
//

[T]
overload BigFloat() = BigFloat(array(0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u,
             0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u),db_zero(), 0, 1);



[T] overload BitwiseMovedType?(static BigFloat) = true;

[T]
inline overload resetUnsafe(a:BigFloat) {
    a <-- BigFloat();
}



//
// generic vector requirements
//

[T]
BigFloat?(static BigFloat) = true;


var scs_zer = BigFloat(array(0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u,
             0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u),
             db_zero(),  0,   1 );
/* 1/2 */
var    scs_half = BigFloat(array(0x20000000u, 0x00000000u, 0x00000000u, 0x00000000u,
             0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u),
             db_one(), -1,   1 );
/*  1  */
var    scs_one = BigFloat(array(0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u,
             0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u),
             db_one(),  0,   1 );
/*  2  */
var    scs_two = BigFloat(array(0x00000002u, 0x00000000u, 0x00000000u, 0x00000000u,
             0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u),
             db_one(),  0,   1 );
/* 0.166666*/
var    scs_sixinv = BigFloat(array(0x0aaaaaaau, 0x2aaaaaaau, 0x2aaaaaaau, 0x2aaaaaaau,
	     0x2aaaaaaau, 0x2aaaaaaau, 0x2aaaaaaau, 0x2aaaaaaau),
	     db_one(),  -1,   1 );


overload BigFloat(x:Double) --> result:BigFloat {
    var nb, mantissa = db_number(),db_number();

    if(x>=0){result.sign = 1;    nb.2 = x;}
    else    {result.sign = -1;   nb.2 = -x;}

    var exponent = bitand(nb.0[1] , 0x7ff00000);

    if (exponent == 0x7ff00000)  {
        /*
        * x = +/- Inf, s/qNAN
        */
        result.excp.2 = x;
        for(i in range(SCS_NB_WORDS))
            result.h_word[i] = 0;
        result.index = 0;
        result.sign = 1;
    }

    else {    /* Normals,  denormals, +/- 0.  */

        /* This number is not an exception */
        result.excp.2 = 1.;

        if (exponent == 0){
            /* x is a denormal number : bring it back to the normal range */
            nb.2 = nb.2 * radix_two_double;      /* 2^(2.SCS_NB_BITS) */
            exponent = bitand(nb.0[1] , 0x7ff00000);
            result.index = -2;
        }else {
            result.index = 0;
        }

        exponent = bitshr(exponent,20);  /* get the actual value */

        var ind = ((exponent +(100*SCS_NB_BITS - 1023))/SCS_NB_BITS) - 100;
        /* means : = (exponent -1023 + 100*SCS_NB_BITS)/SCS_NB_BITS -100
         The business with 100*SCS_NB_BITS is to stay within the positive
         range for exponent_remainder between 1 and SCS_NB_BITS */

        var exponent_remainder = exponent - 1022 - (SCS_NB_BITS*ind);

        result.index += ind;

        /* now get the mantissa and add the implicit 1 in fp. format*/
        mantissa.1 = bitor(bitand(nb.1 , 0x000ffffffffffffful) , 0x0010000000000000ul);

        /* and spread it over the structure
           Everything here is 64-bit arithmetic */
        result.h_word[0] =  UInt32(bitshr(mantissa.1 , 53 - exponent_remainder ));

        /* 11 = 64-53 */
        mantissa.1 =  bitshl(mantissa.1 , exponent_remainder+11);
        result.h_word[1] = bitand(bitshr(mantissa.0[1] , 32 - SCS_NB_BITS) , SCS_MASK_RADIX );
        mantissa.1 =  bitshl(mantissa.1 , SCS_NB_BITS);
        result.h_word[2] = bitand(bitshr(mantissa.0[1] , (32 - SCS_NB_BITS)), SCS_MASK_RADIX);
        result.h_word[3] = 0 ;
        result.h_word[4] = 0; result.h_word[5] = 0; result.h_word[6] = 0; result.h_word[7] = 0;
    } /* end if test NaN etc */
}

overload Double(x:BigFloat) --> result:Double {
    var nb, rndcorr = db_number(), db_number();
    var res = 0.;
    /* convert the MSB digit into a double, and store it in nb.d */
    nb.2 = Double(x.h_word[0]);
    /* place the two next digits in lowpart */
    var t1 = UInt64(x.h_word[1]);
    var lowpart = bitshl(t1,SCS_NB_BITS) + x.h_word[2];
    /* there is at least one significant bit in nb,
       and at least 2*SCS_NB_BITS in lowpart,
       so provided SCS_NB_BITS >= 27
       together they include the 53+ guard bits to decide rounding
    */

    /* test for  s/qNan, +/- Inf, +/- 0, placed here for obscure performance reasons */
    if (x.excp.2 != 1.)
        result <-- x.excp.2;
    /* take the exponent of nb.d (will be in [0:SCS_NB_BITS])*/
    var expo = bitshr(bitand(nb.0[1] , 0x7ff00000),20) - 1023;
    /* compute the exponent of the result */
    var expofinal = expo + SCS_NB_BITS*x.index;
    /* Is the SCS number not too large for the IEEE exponent range ? */
    if (expofinal >  1023)
        /* return an infinity */
        res = radix_rng_double*radix_rng_double;
    /* Is our SCS number a denormal  ? */
    else if (expofinal >= -1022){
        /* x is in the normal range */
        var shift = expo+2*SCS_NB_BITS-53;
        var roundbits = bitshl(lowpart,64-shift);
        /* align the rest of the mantissa to nb : shift by (2*SCS_NB_BITS)-53+expo */
        lowpart = bitshr(lowpart,shift);
        /* Look at the last bit to decide rounding */
        if (bitand(lowpart , 0x0000000000000001ul)!=0){
            /* Test for the round to even case */
            if(roundbits==0)
                for (i in range(3,SCS_NB_WORDS))
                    roundbits = bitor(roundbits , x.h_word[i]);
            if(roundbits == 0) {
                /* round to even mantissa */
                if (bitand(lowpart , 0x0000000000000002ul)!=0){
                    /* mantissa odd, need to add an half-ulp */
                    rndcorr.0[0] = 0;
                    rndcorr.0[1] = bitshl(expo-52+1023,20);    /* 2^(exp-52) */
                }
                else
                    rndcorr.2 = 0.0;
            }
            else { /* there are round bits need to add an half-ulp */
                rndcorr.0[0] = 0;
                rndcorr.0[1] = bitshl(expo-52+1023,20);    /* 2^(exp-52) */
            }
        }
        else{
            /* need to add nothing*/
            rndcorr.2 = 0.0;
        }
        lowpart = bitshr(lowpart,1);
        nb.1 = bitor(nb.1,lowpart);    /* Finish to fill the mantissa */
        res  = nb.2 + rndcorr.2;  /* rounded to nearest   */
        /* now compute the exponent from the index :
           we need to multiply res by 2^(X_IND*SCS_NB_BITS)
           First check this number won't be a denormal itself */
        if(x.index*SCS_NB_BITS +1023 > 0) {
            /* build the double 2^(X_IND*SCS_NB_BITS)   */
            nb.0[1] = bitshl(x.index*SCS_NB_BITS +1023,20);
            nb.0[0] = 0;
            res *= nb.2;     /* exact multiplication */
        }
        else {
            /*offset the previous computation by 2^(2*SCS_NB_BITS) */
            /* build the double 2^(X_IND*SCS_NB_BITS)   */
            nb.0[1] = bitshl(x.index*SCS_NB_BITS +1023 + 2*SCS_NB_BITS,20);
            nb.0[0] = 0;
            res *= radix_mtwo_double;  /* exact multiplication */
            res *= nb.2;                  /* exact multiplication */
        }

    }
    else {
        /* the final number is a denormal with 52-(expfinal+1022)
         significant bits. */
        if (expofinal < -1022 - 53 )
            res = 0.;
        else {
            /* align the rest of the mantissa to nb */
            lowpart = bitshr(lowpart , expo+(2*SCS_NB_BITS)-52);
            /* Finish to fill the mantissa */
            nb.1 = bitor(nb.1,lowpart);
            /* this is still a normal number.
            Now remove its exponent and add back the implicit one */
            nb.1 = bitor(bitand(nb.1,0x000FFFFFFFFFFFFFul), 0x0010000000000000ul);
            /* keep only the significant bits */
            nb.1 = bitshr(nb.1,-1023 - expofinal);
            /* Look at the last bit to decide rounding */
            if (bitand(nb.0[0] , 0x00000001)==1){
                /* need to add an half-ulp */
                rndcorr.1 = 1;    /* this is a full ulp but we multiply by 0.5 in the end */
            }else{
                /* need to add nothing*/
                rndcorr.2 = 0.0;
            }
            res  = 0.5*(nb.2 + rndcorr.2);  /* rounded to nearest   */

            /* the exponent field is already set to zero so that's all */
        }
    }
    /* sign management */
    if (x.sign < 0)
        result <-- -res;
    else
        result <-- res;
}


inline SCS_CARRY_PROPAGATE(r1,r0,tmp) {
    tmp = bitshr(UInt64(r1),SCS_NB_BITS);
    r0 += tmp;
    r1 -= bitshl(tmp,SCS_NB_BITS);
}


// This function copies a result into another. There is an unrolled
// version for the case SCS_NB_WORDS==8.
inline overload assign(result:BigFloat, x:BigFloat) : {
    result.h_word[0] = x.h_word[0]; result.h_word[1] = x.h_word[1];
    result.h_word[2] = x.h_word[2]; result.h_word[3] = x.h_word[3];
    result.h_word[4] = x.h_word[4]; result.h_word[5] = x.h_word[5];
    result.h_word[6] = x.h_word[6]; result.h_word[7] = x.h_word[7];
    result.excp.2 <-- x.excp.2;
    result.index = x.index;
    result.sign = x.sign;
}


inline overload multiply(x:BigFloat, y:BigFloat) --> result:BigFloat {
    result.excp.2 = x.excp.2 * y.excp.2;
    result.sign = x.sign * y.sign;
    result.index = x.index + y.index;

    /* Partial products computation */
    var x7,y7,x6,y6 = UInt64(x.h_word[7]),y.h_word[7],UInt64(x.h_word[6]),y.h_word[6];
    var x5,y5,x4,y4 = UInt64(x.h_word[5]),y.h_word[5],UInt64(x.h_word[4]),y.h_word[4];
    var x3,y3,x2,y2 = UInt64(x.h_word[3]),y.h_word[3],UInt64(x.h_word[2]),y.h_word[2];
    var x1,y1,x0,y0 = UInt64(x.h_word[1]),y.h_word[1],UInt64(x.h_word[0]),y.h_word[0];

    var r8 = x7*y1 + x6*y2 + x5*y3 + x4*y4 + x3*y5 + x2*y6 + x1*y7;
    var r7 = x7*y0 + x6*y1 + x5*y2 + x4*y3 + x3*y4 + x2*y5 + x1*y6 + x0*y7;
    var r6 = x6*y0 + x5*y1 + x4*y2 + x3*y3 + x2*y4 + x1*y5 + x0*y6;
    var r5 = x5*y0 + x4*y1 + x3*y2 + x2*y3 + x1*y4 + x0*y5;
    var r4 = x4*y0 + x3*y1 + x2*y2 + x1*y3 + x0*y4;
    var r3 = x3*y0 + x2*y1 + x1*y2 + x0*y3;
    var r2 = x2*y0 + x1*y1 + x0*y2;
    var r1 = x1*y0 + x0*y1;
    var r0 = x0*y0;

    var val,tmp = 0ul,0ul;
    /* Carry Propagate */
    SCS_CARRY_PROPAGATE(r8,r7,tmp);
    SCS_CARRY_PROPAGATE(r7,r6,tmp);
    SCS_CARRY_PROPAGATE(r6,r5,tmp);
    SCS_CARRY_PROPAGATE(r5,r4,tmp);
    SCS_CARRY_PROPAGATE(r4,r3,tmp);
    SCS_CARRY_PROPAGATE(r3,r2,tmp);
    SCS_CARRY_PROPAGATE(r2,r1,tmp);
    SCS_CARRY_PROPAGATE(r1,r0,tmp);
    SCS_CARRY_PROPAGATE(r0,val,tmp);

    if(val != 0){
        /* shift all the digits ! */
        result.h_word[0] = UInt(val); result.h_word[1] = UInt(r0); result.h_word[2] = UInt(r1);  result.h_word[3] = UInt(r2);
        result.h_word[4] = UInt(r3);  result.h_word[5] = UInt(r4); result.h_word[6] = UInt(r5);  result.h_word[7] = UInt(r6);
        inc(result.index);
    }
    else {
        result.h_word[0] = UInt(r0); result.h_word[1] = UInt(r1); result.h_word[2] = UInt(r2); result.h_word[3] = UInt(r3);
        result.h_word[4] = UInt(r4); result.h_word[5] = UInt(r5); result.h_word[6] = UInt(r6); result.h_word[7] = UInt(r7);
    }

}


//Square BigFloat
square(x:BigFloat) :BigFloat {
    var result = BigFloat();
    result.excp.1 = x.excp.1 * x.excp.1;
    result.index = x.index + x.index;
    result.sign = 1;

    /*
    * Partial products
    */
    var x7,x6,x5,x4 = UInt64(x.h_word[7]),UInt64(x.h_word[6]),UInt64(x.h_word[5]),UInt64(x.h_word[4]);
    var x3,x2,x1,x0 = UInt64(x.h_word[3]),UInt64(x.h_word[2]),UInt64(x.h_word[1]),UInt64(x.h_word[0]);

    var r0 =  x0*x0;
    var r1 = (x0*x1)* 2. ;
    var r2 =  x1*x1 + (x0*x2*2.);
    var r3 = (x1*x2 +  x0*x3)* 2.;
    var r4 =  x2*x2 + (x1*x3 + x0*x4)* 2.;
    var r5 = (x2*x3 +  x1*x4 + x0*x5)* 2.;
    var r6 =  x3*x3 + (x2*x4 + x1*x5 + x0*x6)* 2.;
    var r7 = (x3*x4 +  x2*x5 + x1*x6 + x0*x7)* 2.;
    var r8 =  x4*x4 + (x3*x5 + x2*x6 + x1*x7)* 2.;

    var val,tmp = 0ul,0ul;
    /* Carry propagation */
    SCS_CARRY_PROPAGATE(r8,r7,tmp);
    SCS_CARRY_PROPAGATE(r7,r6,tmp);
    SCS_CARRY_PROPAGATE(r6,r5,tmp);
    SCS_CARRY_PROPAGATE(r5,r4,tmp);
    SCS_CARRY_PROPAGATE(r4,r3,tmp);
    SCS_CARRY_PROPAGATE(r3,r2,tmp);
    SCS_CARRY_PROPAGATE(r2,r1,tmp);
    SCS_CARRY_PROPAGATE(r1,r0,tmp);
    SCS_CARRY_PROPAGATE(r0,val,tmp);

    if(val != 0){
        /* shift all the digits ! */
        result.h_word[0] = UInt(val); result.h_word[1] = UInt(r0); result.h_word[2] = UInt(r1);  result.h_word[3] = UInt(r2);
        result.h_word[4] = UInt(r3);  result.h_word[5] = UInt(r4); result.h_word[6] = UInt(r5);  result.h_word[7] = UInt(r6);
        inc(result.index);
    }
    else {
        result.h_word[0] = UInt(r0); result.h_word[1] = UInt(r1); result.h_word[2] = UInt(r2); result.h_word[3] = UInt(r3);
        result.h_word[4] = UInt(r4); result.h_word[5] = UInt(r5); result.h_word[6] = UInt(r6); result.h_word[7] = UInt(r7);
    }
    return result;
}



/* The function that does the work in case of an addition

 do_add is the function that does the addition of two SCS numbers,
   assuming that x.sign == y.sign, X_IND > Y_IND, x and y both
   non-zero.
 */

private inline do_add(result, x, y) : {
    var r0,r1,r2,r3,r4,r5,r6,r7 = 0,0,0,0,0,0,0,0;
    var Diff  = x.index - y.index;
    result.excp.1 = x.excp.1 + y.excp.1 - 1;
    result.index = x.index;
    result.sign = x.sign;

    switch (Diff)
        case (0){
            r0 = x.h_word[0] + y.h_word[0]; r1 = x.h_word[1] + y.h_word[1];
            r2 = x.h_word[2] + y.h_word[2]; r3 = x.h_word[3] + y.h_word[3];
            r4 = x.h_word[4] + y.h_word[4]; r5 = x.h_word[5] + y.h_word[5];
            r6 = x.h_word[6] + y.h_word[6]; r7 = x.h_word[7] + y.h_word[7];
        }
        case (1){
            r0 = x.h_word[0];           r1 = x.h_word[1] + y.h_word[0];
            r2 = x.h_word[2] + y.h_word[1]; r3 = x.h_word[3] + y.h_word[2];
            r4 = x.h_word[4] + y.h_word[3]; r5 = x.h_word[5] + y.h_word[4];
            r6 = x.h_word[6] + y.h_word[5]; r7 = x.h_word[7] + y.h_word[6];
        }
        case (2){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2] + y.h_word[0]; r3 = x.h_word[3] + y.h_word[1];
            r4 = x.h_word[4] + y.h_word[2]; r5 = x.h_word[5] + y.h_word[3];
            r6 = x.h_word[6] + y.h_word[4]; r7 = x.h_word[7] + y.h_word[5];
        }
        case (3){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2];           r3 = x.h_word[3] + y.h_word[0];
            r4 = x.h_word[4] + y.h_word[1]; r5 = x.h_word[5] + y.h_word[2];
            r6 = x.h_word[6] + y.h_word[3]; r7 = x.h_word[7] + y.h_word[4];
        }
        case (4){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2];           r3 = x.h_word[3];
            r4 = x.h_word[4] + y.h_word[0]; r5 = x.h_word[5] + y.h_word[1];
            r6 = x.h_word[6] + y.h_word[2]; r7 = x.h_word[7] + y.h_word[3];
        }
        case (5){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2];           r3 = x.h_word[3];
            r4 = x.h_word[4];           r5 = x.h_word[5] + y.h_word[0];
            r6 = x.h_word[6] + y.h_word[1]; r7 = x.h_word[7] + y.h_word[2];
        }
        case (6){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2];           r3 = x.h_word[3];
            r4 = x.h_word[4];           r5 = x.h_word[5];
            r6 = x.h_word[6] + y.h_word[0]; r7 = x.h_word[7] + y.h_word[1];
        }
        case (7){
            r0 = x.h_word[0];           r1 = x.h_word[1];
            r2 = x.h_word[2];           r3 = x.h_word[3];
            r4 = x.h_word[4];           r5 = x.h_word[5];
            r6 = x.h_word[6];           r7 = x.h_word[7] + y.h_word[0];
        }
        else{
            /* Diff >= 8*/
            result.h_word[0] = x.h_word[0]; result.h_word[1] = x.h_word[1];
            result.h_word[2] = x.h_word[2]; result.h_word[3] = x.h_word[3];
            result.h_word[4] = x.h_word[4]; result.h_word[5] = x.h_word[5];
            result.h_word[6] = x.h_word[6]; result.h_word[7] = x.h_word[7];
        }

    /* Carry propagation */

    var carry = bitshr(r7 , SCS_NB_BITS); r6 += carry;  r7 = bitand(r7 , SCS_MASK_RADIX);
    carry = bitshr(r6 , SCS_NB_BITS); r5 += carry;  r6 = bitand(r6 , SCS_MASK_RADIX);
    carry = bitshr(r5 , SCS_NB_BITS); r4 += carry;  r5 = bitand(r5 , SCS_MASK_RADIX);
    carry = bitshr(r4 , SCS_NB_BITS); r3 += carry;  r4 = bitand(r4 , SCS_MASK_RADIX);
    carry = bitshr(r3 , SCS_NB_BITS); r2 += carry;  r3 = bitand(r3 , SCS_MASK_RADIX);
    carry = bitshr(r2 , SCS_NB_BITS); r1 += carry;  r2 = bitand(r2 , SCS_MASK_RADIX);
    carry = bitshr(r1 , SCS_NB_BITS); r0 += carry;  r1 = bitand(r1 , SCS_MASK_RADIX);
    carry = bitshr(r0 , SCS_NB_BITS);

    if (carry!=0){
        result.h_word[7] = r6; result.h_word[6] = r5;  result.h_word[5] = r4; result.h_word[4] = r3;
        result.h_word[3] = r2; result.h_word[2] = r1;  result.h_word[1] = bitand(r0 , SCS_MASK_RADIX);
        result.h_word[0] = 1 ;
        inc(result.index);
    }
    else {
        result.h_word[0] = r0; result.h_word[1] = r1; result.h_word[2] = r2; result.h_word[3] = r3;
        result.h_word[4] = r4; result.h_word[5] = r5; result.h_word[6] = r6; result.h_word[7] = r7;
    }
}



/*/////////////////////////////////////////////////////////////////
/////////////////////// SUBTRACTION //////////////////////////////
//////////////////////////////////////////////////////////////////
// This procedure assumes :
// -    X_IND >= Y_IND
// -   X_SIGN != Y_SIGN
//    neither x or y is zero
//  and result = x - y
*/


private inline do_sub(result, x, y){
    var res = Array[Int,SCS_NB_WORDS]();

    result.excp.1 = x.excp.1 + y.excp.1 - 1;
    var Diff  = x.index - y.index;
    result.index = x.index;

    /* The easy case */
    if(Diff >= SCS_NB_WORDS)
        result = x;
    else {
        /* 0 <= Diff <= (SCS_NB_WORDS-1) */
        var carry = 0;
        if(Diff==0) {

            var i,cp = 0,0;
            while((x.h_word[i] == y.h_word[i]) and (i<SCS_NB_WORDS))
                inc(i);
            if (x.h_word[i] > y.h_word[i])
                cp = 1;
            else if (x.h_word[i] < y.h_word[i])
                cp = -1;
            else
                cp = 0;

            if (cp == 0) {
                /* Yet another easy case: result = 0 */
                scs_zero(result);
                return;
            }
            else { /* cp <> 0 */
                if (cp > 0){
                    /* x > y */
                    result.sign = x.sign;
                    for(i in reverseRange(SCS_NB_WORDS-1,0)){
                        var s = (Int(x.h_word[i]) - y.h_word[i] - carry);
                        carry = bitshr(bitand(s,SCS_RADIX),SCS_NB_BITS);
                        res[i] = (bitand(s,SCS_RADIX) + s);
                    }
                }
                else { /* cp < 0  */
                    /* x < y (change of sign) */
                    result.sign = - x.sign;
                    for(i in reverseRange((SCS_NB_WORDS-1),0)){
                        var s = (- Int(x.h_word[i]) + y.h_word[i] - carry);
                        carry = bitshr(bitand(s,SCS_RADIX),SCS_NB_BITS);
                        res[i] = (bitand(s,SCS_RADIX) + s);
                    }
                }
            }
        }
        else {
            /* 1<=Diff<(SCS_NB_WORDS-1) Digits of x and y overlap but the
            * sign will be that of x */
            result.sign = x.sign;
            var s,i,j = 0,(SCS_NB_WORDS-1),(SCS_NB_WORDS-1)-Diff;
            while(i >= 0){
                if(j >= 0)
                    s = (x.h_word[i] - y.h_word[j] - carry);
                else
                    s = (x.h_word[i] - carry);
                carry = bitshr(bitand(s,SCS_RADIX),SCS_NB_BITS);
                res[i] = (bitand(s,SCS_RADIX) + s);
                dec(i);
                dec(j);
            }
        }
        /* check for cancellations */
        var i=0;
        while ((res[i]==0) and (i < SCS_NB_WORDS))
            inc(i);
        if(i>0) { /* cancellation, shift result*/
            result.index -= i;
            var j = 0;
            while(i<SCS_NB_WORDS){
                result.h_word[j] = (res[i]);
                inc(i);
                inc(j);
            }
            while(j<SCS_NB_WORDS){
                result.h_word[j] = 0;
                inc(j);
            }
        }
        else {
            for(i in range(SCS_NB_WORDS))
                result.h_word[i] =  (res[i]);
        }
    }

}



/** SCS addition (result is a normalised SCS number).

 */
inline overload add(x:BigFloat, y:BigFloat) --> result:BigFloat {
    if (x.excp.0[1] == 0)
        result <-- y;
    else if (y.excp.0[1] == 0)
        result <-- x;
    else if (x.sign == y.sign)
        if(x.index >= y.index)
            do_add(result,x,y);
        else
            do_add(result,y,x);
    else
        if(x.index >= y.index)
            do_sub(result,x,y);
        else
            do_sub(result,y,x);
}


/** SCS subtraction (result is a normalised SCS number).

 The arguments x, y and result may point to the same memory
 location.
 */
inline overload subtract(x:BigFloat, y:BigFloat) --> result:BigFloat {
    if (x.excp.0[1] == 0){
        result <-- y;
        result.sign = -result.sign;
    }
    else if (y.excp.0[1] == 0)
        result <-- x;
    else if (x.sign == y.sign)
        /* Same sign, so it's a sub   */
        if(x.index >= y.index)
            do_sub(result,x,y);
        else{
            do_sub(result,y,x);
            result.sign = -result.sign;
        }
    else
        if(x.index >= y.index)
            do_add(result,x,y);
        else{
            do_add(result,y,x);
            result.sign = -result.sign;
        }
}


/*
 * Compute 1/x with a Newton scheme
 */
[n | n==1]
inline overload divide(static n, x:BigFloat) --> result:BigFloat {
    var tmp = x;
    tmp.index = 0;
    var app_x = Double(tmp);
    /* inv is a 53-bit approximation of 1/x */
    var inv = 1./app_x;
    var res = BigFloat(inv);
    res.index -= x.index;

    /* First Newton Iteration */
    var res1 = x * res;
    res1 = scs_two - res1;
    res = res * res1;

    /* Second Newton Iteration */
    res1 = x * res;
    res1 = scs_two - res1;
    result <-- res * res1;
}


/*
 * Compute result = x/y;
 */
inline overload divide(x:BigFloat, y:BigFloat) --> result:BigFloat {
    if (x.excp.1 != 1)
        result.excp.1 = x.excp.1 / y.excp.1;
    else{
        var res = 1./y;
        result <-- res * x;
    }
}

[n | n==0]
inline overload assign(result:BigFloat, static n) {
    for(i in range(SCS_NB_WORDS))
        result.h_word[i] = 0;
    result.excp.1 = 0;
    result.index = 0;
    result.sign = 1;
}


/**
  Convert an integer number in it scs multiprecision
  representation
 */
[I | Integer?(I)]
overload BigFloat(x:I) :BigFloat {
    var result = BigFloat();
    var ux = 0u;
    if(x >= 0){
        result.sign = 1;
        ux = UInt(x);
    }
    else{
        result.sign = -1;
        ux = UInt(-x);
    }

    if (ux > SCS_RADIX){
        result.index = 1;
        result.h_word[0] = bitshr(ux - SCS_RADIX, SCS_NB_BITS);
        result.h_word[1] =  ux -  bitshl(result.h_word[0] , SCS_NB_BITS);
    }else {
        result.index = 0;
        result.h_word[0] = ux;
        result.h_word[1] = 0;
    }

    for(i in range(2,SCS_NB_WORDS))
        result.h_word[i] = 0;

    if (x != 0)
        result.excp.1 = 1;
    else
        result.excp.1 = 0;
    return result;
}

