// complex exp function

public import math.native.*;
import math.native.kernel.ieee754.*;
import math.native.kernel.k_exp.*;

private alias exp_ovfl  = 0x40862e42u;			/* high bits of MAX_EXP * ln2 ~= 710 */
private alias cexp_ovfl = 0x4096b8e4u;			/* (MAX_EXP - MIN_DENORM_EXP) * ln2 */

overload exp(z:ComplexDouble) {
	
	var x,y = real(z), imagValue(z);
	var ydb = MAKE_IEEE( y);
	GET_IEEE_HIGH(ydb) = bitand(GET_IEEE_HIGH(ydb),MM);

	/* cexp(x + I 0) = exp(x) + I 0 */
	if (bitor(GET_IEEE_HIGH(ydb),GET_IEEE_LOW(ydb)) == 0)
		return Complex(exp(x), y);
	var xdb =MAKE_IEEE( x);
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if (bitor(bitand(GET_IEEE_HIGH(xdb), MM) , GET_IEEE_LOW(xdb)) == 0)
		return Complex(cos(y), sin(y));

	if (GET_IEEE_HIGH(ydb) >= EM) {
		if (GET_IEEE_LOW(xdb) != 0 or bitand(GET_IEEE_HIGH(xdb),MM) != EM) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			return Complex(y - y, y - y);
		} 
		else if (bitand(GET_IEEE_HIGH(xdb),SM)!=0) {
			/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
			return Complex(0.0, 0.0);
		} 
		else {
			/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
			return Complex(x, y - y);
		}
	}

	if (GET_IEEE_HIGH(xdb) >= exp_ovfl and GET_IEEE_HIGH(xdb) <= cexp_ovfl) {
		/*
		 * x is between 709.7 and 1454.3, so we must scale to avoid
		 * overflow in exp(x).
		 */
		return __ldexp_cexp(z, 0);
	} 
	else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		var exp_x = exp(x);
		return Complex(exp_x * cos(y), exp_x * sin(y));
	}
}
