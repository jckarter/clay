// exp function adapted from openlibm


import math.native.kernel.ieee754.*;
import math.*;



overload exp(a:Double) { /* default IEEE double exp */
	alias halF 			= array(0.5,-0.5);
	alias o_threshold	= 7.09782712893383973096e+02;/* 0x40862E42, 0xFEFA39EF */
	alias u_threshold 	= -7.45133219101941108420e+02;  /* 0xc0874910, 0xD52D3051 */
	alias ln2HI			= array(6.93147180369123816490e-01,-6.93147180369123816490e-01);/* 0x3fe62e42, 0xfee00000 */
	alias ln2LO			= array(1.90821492927058770002e-10,-1.90821492927058770002e-10);/* 0x3dea39ef, 0x35793c76 */
	alias TWOM1000 = 9.33263618503218878990e-302;     /* 2**-1000=0x01700000,0*/
	alias ONE = 1.;
	alias HUGE = GreatestPositiveFinite(Double);
	alias TINY = LeastPositive(Double);

	var x = a;
	var y,hi,lo,k = 0.,0.,0.,0;
	var xdb = MAKE_IEEE(x);
	var xsb = bitand(bitshr(GET_IEEE_HIGH(xdb),31),1);		/* sign bit of x */
	GET_IEEE_HIGH(xdb) = bitand(GET_IEEE_HIGH(xdb),MM);		/* high word of |x| */

    // filter out non-finite argument
	if(GET_IEEE_HIGH(xdb) >= CV14) {			/* if |x|>=709.78... */
        if(GET_IEEE_HIGH(xdb) >= EM) {
	        if(bitor(bitand(GET_IEEE_HIGH(xdb),0xfffff),GET_IEEE_LOW(xdb))!=0)
		    	return x+x; 		/* NaN */
			else 
				return if(xsb==0) x else 0.;	/* exp(+-inf)={inf,0} */
	    }
	    if(x > o_threshold) return HUGE*HUGE; /* overflow */
	    if(x < u_threshold) return TWOM1000*TWOM1000; /* underflow */
	}

    // argument reduction 
	if(GET_IEEE_HIGH(xdb) > CV15) {		/* if  |x| > 0.5 ln2 */ 
	    if(GET_IEEE_HIGH(xdb) < CV16) {	/* and |x| < 1.5 ln2 */
			hi = x-ln2HI[xsb]; 
			lo = ln2LO[xsb]; 
			k = 1-xsb-xsb;
	    } 
	    else {
			k  = Int(IVLN2*x+halF[xsb]);
			var t  = Double(k);
			hi = x - t*ln2HI[0];	/* t*ln2HI is exact here */
			lo = t*ln2LO[0];
	    }
	    x <-- hi - lo;
	} 
	else if(GET_IEEE_HIGH(xdb) < CV18)  {	/* when |x|<2**-28 */
	    if(HUGE+x>ONE) return ONE+x;/* trigger inexact */
	}
	else 
		k = 0;

    /* x is now in primary range */
	var t,twopk  = x*x, 0.;
	if(k >= -1021)
	    twopk = MAKE_IEEE(RM+bitshl(k,20), 0).2;
	else
	    twopk = MAKE_IEEE(RM+bitshl(k+1000,20), 0).2;
	var c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
	if(k==0) return ONE-((x*c)/(c-2.0)-x); 
	else 		y = ONE-((lo-(x*c)/(2.0-c))-hi);
	if(k >= -1021) {
	    if (k==1024) return y*2.0*0x1p1023;
	    return y*twopk;
	} else {
	    return y*twopk*TWOM1000;
	}
}


/*
 * Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]:
 * |x*(exp(x)+1)/(exp(x)-1) - p(x)when < 2**-27.74
 */

overload exp(a:Float) {
	alias fhalF	= array(0.5f,-0.5f);
	alias fo_threshold=  8.8721679688e+01f; /* 0x42b17180 */
	alias fu_threshold= -1.0397208405e+02f;  /* 0xc2cff1b5 */
	alias fln2HI   = array( 6.9314575195e-01f,		/* 0x3f317200 */
		     -6.9314575195e-01f);	/* 0xbf317200 */
	alias fln2LO   = array( 1.4286067653e-06f,  	/* 0x35bfbe8e */
		     -1.4286067653e-06f);	/* 0xb5bfbe8e */
	alias finvln2 =  1.4426950216e+00f; 		/* 0x3fb8aa3b */
	alias FP1 =  1.6666625440e-1f;		/*  0xaaaa8f.0p-26 */
	alias FP2 = -2.7667332906e-3f;		/* -0xb55215.0p-32 */

	alias FTWOM1000 = 7.8886090522e-31f;      /* 2**-100=0x0d800000 */
	alias HUGE = GreatestPositiveFinite(Float);
	alias ONE = 1.f;
	var x = a;
	var hx = GET_FLOAT_WORD(x);
	var xsb = bitand(bitshr(hx,31),1);		/* sign bit of x */
	hx = bitand(hx,0x7fffffff);		/* high word of |x| */

    /* filter out non-finite argument */
	if(hx >= 0x42b17218) {			/* if |x|>=88.721... */
	    if(hx>0x7f800000)
		 return x+x;	 		/* NaN */
            if(hx==0x7f800000)
		return if(xsb==0) x else 0.f;		/* exp(+-inf)={inf,0} */
	    if(x > fo_threshold) return HUGE*HUGE; /* overflow */
	    if(x < fu_threshold) return FTWOM1000*FTWOM1000; /* underflow */
	}

	var nx,hi,lo,k = 0.f,0.f,0.f,0;
    /* argument reduction */
	if(hx > 0x3eb17218) {		/* if  |x| > 0.5 ln2 */
	    if(hx < 0x3F851592) {	/* and |x| < 1.5 ln2 */
			hi = x-fln2HI[xsb]; 
			lo = fln2LO[xsb]; 
			k = 1-xsb-xsb;
	    } 
	    else {
			k  = Int32(finvln2*x+fhalF[xsb]);
			var t  = k;
			hi = x - t*fln2HI[0];	/* t*ln2HI is exact here */
			lo = t*fln2LO[0];
	    }
	    x <-- hi - lo;
	}
	else if(hx < 0x39000000)  {	/* when |x|<2**-14 */
	    if(HUGE+x>ONE) 
	    	return ONE+x;/* trigger inexact */
	}
	else k = 0;

    /* x is now in primary range */
	var t,twopk  = x*x,0.f;
	if(k >= -125)
	    twopk = SET_FLOAT_WORD(0x3f800000+bitshl(k,23));
	else
	    twopk = SET_FLOAT_WORD(0x3f800000+bitshl(k+100,23));
	
	var c  = x - t*(FP1+t*FP2);
	
	if(k==0) 
		return ONE-((x*c)/(c-2.0f)-x);
	
	var y = ONE-((lo-(x*c)/(2.0f-c))-hi);
	if(k >= -125) {
	    if(k==128) 
	    	return y*2.0f*0x1p127f;
	    return y*twopk;
	} 
	else {
	    return y*twopk*FTWOM1000;
	}
}