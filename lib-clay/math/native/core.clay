
import math.*;
import math.native.exact.(db_number);
import numbers.floats.(nan,signbit,infinity,floatBits,floatFromBits,exponentBias);

//Constants
public alias M_E	    = 2.7182818284590452353602874713526625;  /* e */
public alias M_LOG2E	= 1.4426950408889634073599246810018921;  /* log_2 e */
public alias M_LOG10E	= 0.4342944819032518276511289189166051;  /* log_10 e */
public alias M_LN2	    = 0.6931471805599453094172321214581766;  /* log_e 2 */
public alias M_LN10     = 2.3025850929940456840179914546843642;  /* log_e 10 */
public alias M_PI		= 3.1415926535897932384626433832795029;  /* pi */
public alias M_TWOPI    = 6.2831853071795864769252867665590058;   /* 2*pi */
public alias M_1_TWOPI  = 0.1591549430918953357688837633725143620344596457405; /* 1/(2*pi) */
public alias M_PI_2	    = 1.570796326794896619231321691639751442098584699687;  /* pi/2 */
public alias M_PI_4	    = 0.7853981633974483096156608458198757;  /* pi/4 */
public alias M_1_PI	    = 0.3183098861837906715377675267450287;  /* 1/pi */
public alias M_2_PI	    = 0.6366197723675813430755350534900574;  /* 2/pi */
public alias M_2_SQRTPI = 1.1283791670955125738961589031215452;  /* 2/sqrt(pi) */
public alias M_SQRT2	= 1.4142135623730950488016887242096981;  /* sqrt(2) */
public alias M_SQRT1_2  = 0.7071067811865475244008443621048490;  /* 1/sqrt(2) */
public alias M_COS_PI_4 = 0.707106781186547524400844362104849039284835937688; /* cos(M_PI_4) */
public alias M_COS_PI_8 = 0.923879532511286756128183189396788286822416625863; /* cos(M_PI_4*0.5) */
public alias M_SIN_PI_8 = 0.382683432365089771728459984030398866761344562485; /* sin(M_PI_4*0.5) */


[T | Numeric?(T)]
inline overload max(x:T,y:T) = if(x<y) y else x;

[T | Numeric?(T)]
inline overload min(x:T,y:T) = if(y<x) y else x;

[T] inline overload fma(a:T,b:T,c:T) = (a * b) + c;


[T | Float?(T)]
overload recip(x:T) = T(1)/x;

[T,U | Float?(T,U)]
overload hypot(m:T,n:U) {
    var a = toBiggerNumericType(T,U,m);
    var b = toBiggerNumericType(T,U,n);
    alias T = Type(a);
    alias ZERO = T(0);
    alias ONE = T(1);
    var r = ZERO;
    if (a == ZERO)
        r = abs(b);
    else if (b == ZERO)
        r = abs(a);
    else {
        var x,y = abs(a),abs(b);
        if (x > y){
            var temp = y / x;
            r = x * sqrt(ONE + temp * temp);
        }
        else{
            var temp = x / y;
            r = y * sqrt(ONE + temp * temp);
        }
    }
    return r;
}


[I | Integer?(I)]
inline overload abs(x:I) = if(x >= 0) x else -x;


inline overload sign(x:Long) = bitor(bitshr(x,63),Long(bitshr(ULong(-x),63)));
inline overload sign(x:Int) = bitor(bitshr(x,31),Int(bitshr(UInt(-x),31)));
inline overload sign(x:Short) = bitor(bitshr(x,15),Short(bitshr(UShort(-x),15)));
inline overload sign(x:Byte) = bitor(bitshr(x,7),Byte(bitshr(UByte(-x),7)));



inline overload finite?(x:Double)
	= Bool(bitshr(bitand((Pointer[Int32](&x)+1)^,0x7fffffff)-0x7ff00000,31));

inline overload finite?(x:Float){
	var ix = Int(floatBits(x));
	return Bool(bitshr(wrapCast(UInt,bitand(ix,0x7fffffff)-0x7f800000),31));
}


// Return classification value corresponding to argument.
// enum FPCLS(
//     FP_NAN,
//     FP_INFINITE,
//     FP_ZERO,
//     FP_SUBNORMAL,
//     FP_NORMAL
// );

//For libm compatibility
public alias FP_NAN = 0;
public alias FP_INFINITE = 1;
public alias FP_ZERO = 2;
public alias FP_SUBNORMAL = 3;
public alias FP_NORMAL = 4;


inline overload fpclassify(x:Double) --> res:Int {
    var xdb = db_number(x);
    xdb.0[0] = bitor(xdb.0[0],bitand(xdb.0[1] , 0xfffff));
    xdb.0[1] = bitand(xdb.0[1],0x7ff00000);
    if (bitor(xdb.0[1],xdb.0[0]) == 0)
        res <-- FP_ZERO;
    else if (xdb.0[1] == 0)
        res <-- FP_SUBNORMAL;
    else if (xdb.0[1] == 0x7ff00000)
        res <-- if(xdb.0[0] != 0) FP_NAN else FP_INFINITE;
    else
        res <-- FP_NORMAL;
}

inline overload fpclassify(x:Float) --> res:Int {
    var wx = floatBits(x);
    wx = bitand(wx,0x7fffffff);
	if (wx == 0)
        res <-- FP_ZERO;
    else if (wx < 0x800000)
        res <-- FP_SUBNORMAL;
    else if (wx >= 0x7f800000)
        res <-- if(wx > 0x7f800000) FP_NAN else FP_INFINITE;
    else
        res <-- FP_NORMAL;
}

private define _infinity;

inline overload _infinity(x:Double){
	var xdb = db_number(x);
    xdb.0[0] = bitor(xdb.0[0] , bitxor(bitand(xdb.0[1] , 0x7fffffff) , 0x7ff00000));
	xdb.0[0] = bitor(xdb.0[0],-xdb.0[0]);
	return bitand(bitnot(bitshr(xdb.0[0],31)),bitshr(xdb.0[1],30));
}

inline overload _infinity(x:Float){
	var t = Int(floatBits(x));
	t = bitand(t,0x7fffffff);
	t = bitxor(t,0x7f800000);
	t = bitor(t,-t);
	return bitand(bitnot(bitshr(t,31)) , bitshr(t,30));
}

[T | Float?(T)]
inline overload infinity?(x:T) = if(_infinity(x)==1) true else false;
[T | Float?(T)]
inline overload negativeInfinity?(x:T) = if(_infinity(x)==-1) true else false;


inline overload nan?(x:Double){
	var xdb = db_number(x);
    xdb.0[1] = bitand(xdb.0[1], 0x7fffffff);
    xdb.0[1] = bitor(xdb.0[1] , bitshr(wrapCast(UInt,bitor(xdb.0[0],-xdb.0[0])),31));
	xdb.0[1] = 0x7ff00000 - xdb.0[1];
	return Bool(bitshr(wrapCast(UInt,xdb.0[1]),31));
}

inline overload nan?(x:Float){
	var ix = Int(floatBits(x));
	ix = bitand(ix,0x7fffffff);
	ix = 0x7f800000 - ix;
	return Bool(bitshr(wrapCast(UInt,ix),31));
}

overload llround(x:Float) {
    var result = 0l;
    var i = floatBits(x);
    var j0 = bitand(bitshr(i,23),0xff) - 0x7f;
    var sign = if(bitand(i,0x80000000) != 0) -1l else 1l;
    i = bitor(bitand(i,0x7fffff),0x800000);
    if (j0 < Int(8 * TypeSize(Long)) - 1){
        if (j0 < 0)
            return if(j0 < -1) 0l else sign;
        else if (j0 >= 23)
            result = Long(bitshl(i, (j0 - 23)));
        else {
            i += bitshr(0x400000,j0);
            result = Long(bitshr(i,23 - j0));
        }
    }
    else {
        // The number is too large.  Return implementation default.
        result = Long(x);
    }
    return sign * result;
}

overload llround (x:Double ) {
    var result = 0l;
    var xdb = db_number(x);
    var j0 = bitand(bitshr(xdb.0[1] , 20) , 0x7ff) - 0x3ff;
    var sign = if(bitand(xdb.0[1] , 0x80000000) != 0) -1l else 1l;
    xdb.0[1] = bitor(bitand(xdb.0[1],0xfffff) ,0x100000);
    if (j0 < 20){
        if (j0 < 0)
            return if(j0 < -1) 0l else sign;
        else{
            xdb.0[1] += bitshr(0x80000 , j0);
            result = Long(bitshr(xdb.0[1] , 20 - j0));
        }
    }
    else if (j0 <  Int(8 * TypeSize(Long)) - 1){
        if (j0 >= 52)
            result = bitshl(bitor(bitshl( Long(xdb.0[1]) , 32) , xdb.0[0]) , j0 - 52);
        else{
            var j = xdb.0[0] + bitshr(0x80000000 ,j0 - 20);
            if (j < xdb.0[0])
                inc(xdb.0[1]);
            if (j0 == 20)
                result = Long(xdb.0[1]);
            else
                result = bitor(bitshl(Long(xdb.0[1]) , j0 - 20) , bitshr(j , 52 - j0));
        }
    }
    else{
        // The number is too large.  Return implementation default.
        return Long(x);
    }
    return sign * result;
}

// IEEE functions
// nextafter(x,y)
// return the next machine floating-point number of x in the
// direction toward y.

private alias SGN_MASK = 0x7fffffff;
private alias EXP_MASK = 0x7ff00000;
private alias MIN_SUB = LeastPositive(Double);

overload nextafter(x:Double, y:Double){
	var xdb,ydb = db_number(x),db_number(y);
	alias hx = xdb.0[1];
    alias lx = xdb.0[0];
    alias hy = ydb.0[1];
    alias ly = ydb.0[0];

	if(x == y) return x;
    if(nan?(x) or nan?(y)) return nan(Double);
	if(x == 0.) // x == 0 so return +-minsubnormal
	    return if(signbit(y) == 1) -MIN_SUB else MIN_SUB;// raise underflow flag
	if(hx >= 0)
	    if(hx > hy or (hx == hy and lx > ly)) {	// x > y, x -= ulp
            if(lx == 0) dec(hx);
            dec(lx);
	    } else {	// x < y, x += ulp
            inc(lx);
            if(lx == 0) inc(hx);
	    }
	else
	    if(hy>=0 or hx>hy or ((hx==hy)and(lx>ly))){// x < y, x -= ulp
            if(lx == 0) dec(hx);
            dec(lx);
	    } else {		// x > y, x += ulp
            inc(lx);
            if(lx == 0) inc(hx);
	    }

	hy = bitand(hx,EXP_MASK);
	if(hy >= EXP_MASK)
        return infinity(Double);	// overflow
	if(hy < 0x00100000)		// underflow
	    if(x*x != x)		// raise underflow flag
            return xdb.2;
	return xdb.2;
}

inline overload nextafter(x:Double,y:Float) = nextafter(x,Double(y));
inline overload nextafter(x:Float,y:Double) = nextafter(Double(x),y);


