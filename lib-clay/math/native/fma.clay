
/*
 * A struct dd represents a floating-point number with twice the precision
 * of a double.  We maintain the invariant that "hi" stores the 53 high-order
 * bits of the result.
 */
record dd ( hi:Double, lo:Double);

/*
 * Compute a+b exactly, returning the exact result in a struct dd.  We assume
 * that both a and b are finite, but make no assumptions about their relative
 * magnitudes.
 */
dd_add(a, b) {
	var ret = dd();
	ret.hi = a + b;
	var s = ret.hi - a;
	ret.lo = (a - (ret.hi - s)) + (b - s);
	return ret;
}

/*
 * Compute a+b, with a small tweak:  The least significant bit of the
 * result is adjusted into a sticky bit summarizing all the bits that
 * were lost to rounding.  This adjustment negates the effects of double
 * rounding when the result is added to another number with a higher
 * exponent.  For an explanation of round and sticky bits, see any reference
 * on FPU design, e.g.,
 *
 *     J. Coonen.  An Implementation Guide to a Proposed Standard for
 *     Floating-Point Arithmetic.  Computer, vol. 13, no. 1, Jan 1980.
 */
add_adjusted(a, b) {
	var sum = dd_add(a, b);
	if (sum.lo != 0) {
		var hibits = EXTRACT_WORD64(sum.hi);
		if (bitand(hibits,1) == 0) {
			/* hibits +: (int)copysign(1.0, sum.hi * sum.lo) */
			var lobits = EXTRACT_WORD64(sum.lo);
			hibits +: 1 - bitshr(bitxor(hibits,lobits),62);
			sum.hi = INSERT_WORD64(hibits);
		}
	}
	return sum.hi;
}

/*
 * Compute ldexp(a+b, scale) with a single rounding error. It is assumed
 * that the result will be subnormal, and care is taken to ensure that
 * double rounding does not occur.
 */
add_and_denormalize(a, b, scale) {
	u_int64_t hibits, lobits;
	int bits_lost;

	var sum = dd_add(a, b);

	/*
	 * If we are losing at least two bits of accuracy to denormalization,
	 * then the first lost bit becomes a round bit, and we adjust the
	 * lowest bit of sum.hi to make it a sticky bit summarizing all the
	 * bits in sum.lo. With the sticky bit adjusted, the hardware will
	 * break any ties in the correct direction.
	 *
	 * If we are losing only one bit to denormalization, however, we must
	 * break the ties manually.
	 */
	if (sum.lo != 0) {
		var hibits = EXTRACT_WORD64(sum.hi);
		var bits_lost = -bitand(wrapCast(Int32,bitshr(hibits,52)) , 0x7ffu) - scale + 1;
		if (bits_lost != bitxor(1 , wrapCast(Int32,bitand(hibits,1)))) {
			/* hibits +: (int)copysign(1.0, sum.hi * sum.lo) */
			var lobits = EXTRACT_WORD64(sum.lo);
			hibits +: 1 - bitand(bitshr(bitxor(hibits,lobits),62),2);
			sum.hi = INSERT_WORD64(hibits);
		}
	}
	return ldexp(sum.hi, scale);
}

/*
 * Compute a*b exactly, returning the exact result in a struct dd.  We assume
 * that both a and b are normalized, so no underflow or overflow will occur.
 * The current rounding mode must be round-to-nearest.
 */
dd_mul(a, b) {
	alias split = 0x1p27 + 1.0;
	var ret = dd();
	double ha, hb, la, lb, p, q;

	var p = a * split;
	var ha = a - p;
	ha +: p;
	var la = a - ha;

	p = b * split;
	var hb = b - p;
	hb +: p;
	var lb = b - hb;

	p = ha * hb;
	var q = ha * lb + la * hb;

	ret.hi = p + q;
	ret.lo = p - ret.hi + q + la * lb;
	return ret;
}

/*
 * Fused multiply-add: Compute x * y + z with a single rounding error.
 *
 * We use scaling to avoid overflow/underflow, along with the
 * canonical precision-doubling technique adapted from:
 *
 *	Dekker, T.  A Floating-Point Technique for Extending the
 *	Available Precision.  Numer. Math. 18, 224-242 (1971).
 *
 * This algorithm is sensitive to the rounding precision.  FPUs such
 * as the i387 must be set in double-precision mode if variables are
 * to be stored in FP registers in order to avoid incorrect results.
 * This is the default on FreeBSD, but not on many other systems.
 *
 * Hardware instructions should be used on architectures that support it,
 * since this implementation will likely be several times slower.
 */
overload fma(x:Double, y:Double, z:Double) {
	double xs, ys, zs, adj;
	struct dd xy, r;
	int oround;
	int ex, ey, ez;
	int spread;

	/*
	 * Handle special cases. The order of operations and the particular
	 * return values here are crucial in handling special cases involving
	 * infinities, NaNs, overflows, and signed zeroes correctly.
	 */
	if (x == 0.0 or y == 0.0)
		return x * y + z;
	if (z == 0.0)
		return x * y;
	if (not finite?(x) or not finite?(y))
		return x * y + z;
	if (not finite?(z))
		return z;

	var ex,ey,ez = 0,0,0;
	var xs = frexp(x, @ex);
	var ys = frexp(y, @ey);
	var zs = frexp(z, @ez);
	var oround = fegetround();
	var spread = ex + ey - ez;

	/*
	 * If x * y and z are many orders of magnitude apart, the scaling
	 * will overflow, so we handle these cases specially.  Rounding
	 * modes other than FE_TONEAREST are painful.
	 */
	if (spread < -DBL_MANT_DIG) {
		//feraiseexcept(FE_INEXACT);
		//if (not normal?(z))
			//feraiseexcept(FE_UNDERFLOW);
		switch (oround) 
		case (FE_TONEAREST) return (z);
		case (FE_TOWARDZERO)
			if (bitxor(x > 0.0 , y < 0.0 , z < 0.0))
				return z;
			else
				return nextafter(z, 0);
		case (FE_DOWNWARD)
			if (bitxor(x > 0.0 , y < 0.0))
				return z;
			else
				return nextafter(z, -infinity(Double));
		else	/* FE_UPWARD */
			if (bitxor(x > 0.0 , y < 0.0))
				return nextafter(z, infinity(Double));
			else
				return z;
		}
	}
	if (spread <= DBL_MANT_DIG * 2)
		zs = ldexp(zs, -spread);
	else
		zs = copysign(LeastPositive(Double), zs);

	//fesetround(FE_TONEAREST);

	/*
	 * Basic approach for round-to-nearest:
	 *
	 *     (xy.hi, xy.lo) = x * y		(exact)
	 *     (r.hi, r.lo)   = xy.hi + z	(exact)
	 *     adj = xy.lo + r.lo		(inexact; low bit is sticky)
	 *     result = r.hi + adj		(correctly rounded)
	 */
	var xy = dd_mul(xs, ys);
	var r = dd_add(xy.hi, zs);

	spread = ex + ey;

	if (r.hi == 0.0) {
		/*
		 * When the addends cancel to 0, ensure that the result has
		 * the correct sign.
		 */
		//fesetround(oround);
		var vzs = zs; /* XXX gcc CSE bug workaround */
		return (xy.hi + vzs + ldexp(xy.lo, spread));
	}

	if (oround != FE_TONEAREST) {
		/*
		 * There is no need to worry about double rounding in directed
		 * rounding modes.
		 */
		fesetround(oround);
		adj = r.lo + xy.lo;
		return (ldexp(r.hi + adj, spread));
	}

	var adj = add_adjusted(r.lo, xy.lo);
	if (spread + ilogb(r.hi) > -1023)
		return (ldexp(r.hi + adj, spread));
	else
		return (add_and_denormalize(r.hi, adj, spread));
}
