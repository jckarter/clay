//
// Correctly rounded trigonometric functions
//

import math.native.exact.*;
import numbers.floats.floats.(nan,floatFromBits);
import math.native.scs.*;
import math.native.trig_safe_acc.*;

alias SIN = 0;
alias COS = 1;
alias TAN = 2;

alias XMAX_RETURN_X_FOR_SIN         = 0x3E4FFFFE;        /* .14901147e-7 */
alias XMAX_SIN_CASE2                = 0x3F8921F9;        /* .12271835e-1 */
alias XMAX_RETURN_1_FOR_COS_RN      = 0x3E46A09C;        /* .10536702e-7 */
alias XMAX_RETURN_1_FOR_COS_RDIR    = 0x3E4FFFFE;        /* .14901147e-7 */
alias XMAX_COS_CASE2                = 0x3F8921F9;        /* .12271835e-1 */
alias XMAX_RETURN_X_FOR_TAN         = 0x3E3FFFFE ;       /* .74505735e-8 */
alias XMAX_TAN_CASE2                = 0x3FAFFFFE;        /* .62499940e-1 */

alias ONE_ROUNDED_DOWN      = 9.9999999999999988897769754e-01;

alias EPS_SIN_CASE2         = 1.1843448950468158814341336e-20;
alias RN_CST_SIN_CASE2      = 1.0002134047098797985844841;

alias EPS_COS_CASE2         = 3.7840527971432048221275834e-20;
alias RN_CST_COS_CASE2      = 1.0006823406990255799706351;

alias EPS_SINCOS_CASE3      = 4.0657581468206416275279480e-20;
alias RN_CST_SINCOS_CASE3   = 1.0007331378299121345641375;

alias EPS_TAN_CASE2         = 4.5960200000000000000000000e-19;
alias EPS_TAN_CASE3         = 8.5380921083233474178086908e-20;
alias RN_CST_TAN_CASE3      = 1.0015410958904110700976399;

alias INV_PIO256            = 81.4873308630504119136684868;

alias XMAX_CODY_WAITE_2     = 0x40B921F9;        /* 6433.9756 */
alias XMAX_CODY_WAITE_3     = 0x416921F9;        /* 13176782. */
alias XMAX_DDRR             = 0x426921F9;        /* .86355359e12 */

alias RR_CW2_CH             = 1.2271846303519851062446833e-02;
alias RR_CW2_MCL            = 4.3472122470213191794988193e-13;

alias RR_CW3_CH             = 1.2271845713257789611816406e-02;
alias RR_CW3_CM             = 5.8982729811418721510563046e-10;
alias RR_CW3_MCL            = -4.2111741079360304438362959e-17;

alias RR_DD_MCH             = -1.2271846303085129359367045e-02;
alias RR_DD_MCM             = -4.7837765591693484655225157e-19;
alias RR_DD_CL              = -1.1698319569212264319871158e-35;




var digits_256_over_pi = Array[UInt64,48](
    0x51ul,  	         0x1F306DC9ul,  	 0x3220A94Ful,  	 0x384EAFA3ul,
    0x3A9A6EE0ul,  	 0x1B6C52B3ul,  	 0x9E21C82ul,  	 0x3FCA2C7ul,
    0x15EF5DE2ul,  	 0x2C36E48Dul,  	 0x31D2126Eul,  	 0x25C00C92ul,
    0x177504E8ul,  	 0x32439FC3ul,  	 0x2F58E589ul,  	 0x134E7DD1ul,
    0x11AFA97ul,  	 0x1768909Dul,  	 0xCE38135ul,  	 0x28BEFC82ul,
    0x1CC8EB1Cul,  	 0x306A673Eul,  	 0x24E422FCul,  	 0x177BF250ul,
    0x1D8FFC4Bul,  	 0x3FFBC0B3ul,  	 0x7F7978ul,  	 0x2316B414ul,
    0x368FB69Bul,  	 0xFD9E4F9ul,  	 0x184DBA7Aul,  	 0xC7ECD3Cul,
    0x2FF516BAul,  	 0x24F758FDul,  	 0x1F2F8BD9ul,  	 0x3A0E73EFul,
    0x5294975ul,  	 0xD7F6BF6ul,  	 0x8FC6AE8ul,  	 0x10AC0660ul,
    0x237E3DB5ul,  	 0x357E19F7ul,  	 0x2104D7A1ul,  	 0x2C3B53C7ul,
    0x8B0AF73ul,  	 0x3610CB3ul,  	 0xC2AF8A5ul,  	 0xD0811Cul,
);


var Pio256 = scs(array(0x00c90fdau, 0x28885a30u, 0x234c4c66u, 0x0a2e0370u,
                       0x1cd12902u, 0x13822299u, 0x3cc74020u, 0x2efa98ecu),
                db_one(),  -1,   1 );


var s3  = floatFromBits(0xBFC5555555555555ul) /* -1.6666666667e-01 */;
var s5  = floatFromBits(0x3F81111111111111ul) /* +8.3333333333e-03 */;
var s7  = floatFromBits(0xBF2A01A01A01A01Aul) /* -1.9841269841e-04 */;

var c2  = floatFromBits(0xBFE0000000000000ul) /* -5.0000000000e-01 */;
var c4  = floatFromBits(0x3FA5555555555555ul) /* +4.1666666667e-02 */;
var c6  = floatFromBits(0xBF56C16C16C16C17ul) /* -1.3888888889e-03 */;

var t3h = floatFromBits(0x3FD5555555555555ul) /* +3.3333333333e-01 */;
var t3l = floatFromBits(0x3C7CB8E2B4EE83F1ul) /* +2.4912545352e-17 */;
var t5  = floatFromBits(0x3FC1111111110586ul) /* +1.3333333333e-01 */;
var t7  = floatFromBits(0x3FABA1BA1D1301A5ul) /* +5.3968254136e-02 */;
var t9  = floatFromBits(0x3F9664EC751BE4A4ul) /* +2.1869368217e-02 */;
var t11 = floatFromBits(0x3F823953EFC04F73ul) /* +8.8984067479e-03 */;


/*  sine and cos of kPi/256 in double-double */
var sincosTable = Array[Double,260](
    floatFromBits(0x0000000000000000ul) /* +0.0000000000e+00 */ ,
    floatFromBits(0x0000000000000000ul) /* +0.0000000000e+00 */ ,
    floatFromBits(0x3FF0000000000000ul) /* +1.0000000000e+00 */ ,
    floatFromBits(0x0000000000000000ul) /* +0.0000000000e+00 */ ,
    floatFromBits(0x3F8921D1FCDEC784ul) /* +1.2271538286e-02 */ ,
    floatFromBits(0x3C29878EBE836D9Dul) /* +6.9197907640e-19 */ ,
    floatFromBits(0x3FEFFF62169B92DBul) /* +9.9992470184e-01 */ ,
    floatFromBits(0x3C85DDA3C81FBD0Dul) /* +3.7931082513e-17 */ ,
    floatFromBits(0x3F992155F7A3667Eul) /* +2.4541228523e-02 */ ,
    floatFromBits(0xBBFB1D63091A0130ul) /* -9.1868490126e-20 */ ,
    floatFromBits(0x3FEFFD886084CD0Dul) /* +9.9969881870e-01 */ ,
    floatFromBits(0xBC81354D4556E4CBul) /* -2.9851486404e-17 */ ,
    floatFromBits(0x3FA2D865759455CDul) /* +3.6807222941e-02 */ ,
    floatFromBits(0x3C2686F65BA93AC0ul) /* +6.1060088804e-19 */ ,
    floatFromBits(0x3FEFFA72EFFEF75Dul) /* +9.9932238459e-01 */ ,
    floatFromBits(0xBC88B4CDCDB25956ul) /* -4.2858538441e-17 */ ,
    floatFromBits(0x3FA91F65F10DD814ul) /* +4.9067674327e-02 */ ,
    floatFromBits(0xBC2912BD0D569A90ul) /* -6.7961037205e-19 */ ,
    floatFromBits(0x3FEFF621E3796D7Eul) /* +9.9879545621e-01 */ ,
    floatFromBits(0xBC6C57BC2E24AA15ul) /* -1.2291693337e-17 */ ,
    floatFromBits(0x3FAF656E79F820E0ul) /* +6.1320736302e-02 */ ,
    floatFromBits(0xBC22E1EBE392BFFEul) /* -5.1181134065e-19 */ ,
    floatFromBits(0x3FEFF095658E71ADul) /* +9.9811811290e-01 */ ,
    floatFromBits(0x3C801A8CE18A4B9Eul) /* +2.7935487558e-17 */ ,
    floatFromBits(0x3FB2D52092CE19F6ul) /* +7.3564563600e-02 */ ,
    floatFromBits(0xBC49A088A8BF6B2Cul) /* -2.7784941506e-18 */ ,
    floatFromBits(0x3FEFE9CDAD01883Aul) /* +9.9729045668e-01 */ ,
    floatFromBits(0x3C6521ECD0C67E35ul) /* +9.1647695371e-18 */ ,
    floatFromBits(0x3FB5F6D00A9AA419ul) /* +8.5797312344e-02 */ ,
    floatFromBits(0xBC4F4022D03F6C9Aul) /* -3.3881893831e-18 */ ,
    floatFromBits(0x3FEFE1CAFCBD5B09ul) /* +9.9631261218e-01 */ ,
    floatFromBits(0x3C6A23E3202A884Eul) /* +1.1336497892e-17 */ ,
    floatFromBits(0x3FB917A6BC29B42Cul) /* +9.8017140330e-02 */ ,
    floatFromBits(0xBC3E2718D26ED688ul) /* -1.6345823622e-18 */ ,
    floatFromBits(0x3FEFD88DA3D12526ul) /* +9.9518472667e-01 */ ,
    floatFromBits(0xBC887DF6378811C7ul) /* -4.2486913678e-17 */ ,
    floatFromBits(0x3FBC3785C79EC2D5ul) /* +1.1022220729e-01 */ ,
    floatFromBits(0xBC24F39DF133FB21ul) /* -5.6789503538e-19 */ ,
    floatFromBits(0x3FEFCE15FD6DA67Bul) /* +9.9390697000e-01 */ ,
    floatFromBits(0xBC75DD6F830D4C09ul) /* -1.8964849471e-17 */ ,
    floatFromBits(0x3FBF564E56A9730Eul) /* +1.2241067520e-01 */ ,
    floatFromBits(0x3C4A2704729AE56Dul) /* +2.8354501490e-18 */ ,
    floatFromBits(0x3FEFC26470E19FD3ul) /* +9.9247953460e-01 */ ,
    floatFromBits(0x3C81EC8668ECACEEul) /* +3.1093055095e-17 */ ,
    floatFromBits(0x3FC139F0CEDAF577ul) /* +1.3458070851e-01 */ ,
    floatFromBits(0xBC6523434D1B3CFAul) /* -9.1670359171e-18 */ ,
    floatFromBits(0x3FEFB5797195D741ul) /* +9.9090263543e-01 */ ,
    floatFromBits(0x3C71BFAC7397CC08ul) /* +1.5394565095e-17 */ ,
    floatFromBits(0x3FC2C8106E8E613Aul) /* +1.4673047446e-01 */ ,
    floatFromBits(0x3C513000A89A11E0ul) /* +3.7269471470e-18 */ ,
    floatFromBits(0x3FEFA7557F08A517ul) /* +9.8917650996e-01 */ ,
    floatFromBits(0xBC87A0A8CA13571Ful) /* -4.0987309937e-17 */ ,
    floatFromBits(0x3FC45576B1293E5Aul) /* +1.5885814333e-01 */ ,
    floatFromBits(0xBC5285A24119F7B1ul) /* -4.0163200574e-18 */ ,
    floatFromBits(0x3FEF97F924C9099Bul) /* +9.8730141816e-01 */ ,
    floatFromBits(0xBC8E2AE0EEA5963Bul) /* -5.2332261256e-17 */ ,
    floatFromBits(0x3FC5E214448B3FC6ul) /* +1.7096188876e-01 */ ,
    floatFromBits(0x3C6531FF779DDAC6ul) /* +9.1919980182e-18 */ ,
    floatFromBits(0x3FEF8764FA714BA9ul) /* +9.8527764239e-01 */ ,
    floatFromBits(0x3C7AB256778FFCB6ul) /* +2.3155637028e-17 */ ,
    floatFromBits(0x3FC76DD9DE50BF31ul) /* +1.8303988796e-01 */ ,
    floatFromBits(0x3C61D5EEEC501B2Ful) /* +7.7349918689e-18 */ ,
    floatFromBits(0x3FEF7599A3A12077ul) /* +9.8310548743e-01 */ ,
    floatFromBits(0x3C884F31D743195Cul) /* +4.2170007523e-17 */ ,
    floatFromBits(0x3FC8F8B83C69A60Bul) /* +1.9509032202e-01 */ ,
    floatFromBits(0xBC626D19B9FF8D82ul) /* -7.9910790685e-18 */ ,
    floatFromBits(0x3FEF6297CFF75CB0ul) /* +9.8078528040e-01 */ ,
    floatFromBits(0x3C7562172A361FD3ul) /* +1.8546939998e-17 */ ,
    floatFromBits(0x3FCA82A025B00451ul) /* +2.0711137619e-01 */ ,
    floatFromBits(0xBC687905FFD084ADul) /* -1.0613362529e-17 */ ,
    floatFromBits(0x3FEF4E603B0B2F2Dul) /* +9.7831737072e-01 */ ,
    floatFromBits(0xBC78EE01E695AC05ul) /* -2.1623082233e-17 */ ,
    floatFromBits(0x3FCC0B826A7E4F63ul) /* +2.1910124016e-01 */ ,
    floatFromBits(0xBC1AF1439E521935ul) /* -3.6513812299e-19 */ ,
    floatFromBits(0x3FEF38F3AC64E589ul) /* +9.7570213004e-01 */ ,
    floatFromBits(0xBC7D7BAFB51F72E6ul) /* -2.5572556081e-17 */ ,
    floatFromBits(0x3FCD934FE5454311ul) /* +2.3105810828e-01 */ ,
    floatFromBits(0x3C675B92277107ADul) /* +1.0129787150e-17 */ ,
    floatFromBits(0x3FEF2252F7763ADAul) /* +9.7293995221e-01 */ ,
    floatFromBits(0xBC820CB81C8D94ABul) /* -3.1311211122e-17 */ ,
    floatFromBits(0x3FCF19F97B215F1Bul) /* +2.4298017990e-01 */ ,
    floatFromBits(0xBC642DEEF11DA2C4ul) /* -8.7514315297e-18 */ ,
    floatFromBits(0x3FEF0A7EFB9230D7ul) /* +9.7003125319e-01 */ ,
    floatFromBits(0x3C752C7ADC6B4989ul) /* +1.8365300348e-17 */ ,
    floatFromBits(0x3FD04FB80E37FDAEul) /* +2.5486565960e-01 */ ,
    floatFromBits(0xBC0412CDB72583CCul) /* -1.3602299807e-19 */ ,
    floatFromBits(0x3FEEF178A3E473C2ul) /* +9.6697647104e-01 */ ,
    floatFromBits(0x3C86310A67FE774Ful) /* +3.8496228837e-17 */ ,
    floatFromBits(0x3FD111D262B1F677ul) /* +2.6671275747e-01 */ ,
    floatFromBits(0x3C7824C20AB7AA9Aul) /* +2.0941222579e-17 */ ,
    floatFromBits(0x3FEED740E7684963ul) /* +9.6377606580e-01 */ ,
    floatFromBits(0x3C7E82C791F59CC2ul) /* +2.6463950561e-17 */ ,
    floatFromBits(0x3FD1D3443F4CDB3Eul) /* +2.7851968938e-01 */ ,
    floatFromBits(0xBC6720D41C13519Eul) /* -1.0030273720e-17 */ ,
    floatFromBits(0x3FEEBBD8C8DF0B74ul) /* +9.6043051942e-01 */ ,
    floatFromBits(0x3C7C6C8C615E7277ul) /* +2.4653904815e-17 */ ,
    floatFromBits(0x3FD294062ED59F06ul) /* +2.9028467725e-01 */ ,
    floatFromBits(0xBC75D28DA2C4612Dul) /* -1.8927978708e-17 */ ,
    floatFromBits(0x3FEE9F4156C62DDAul) /* +9.5694033573e-01 */ ,
    floatFromBits(0x3C8760B1E2E3F81Eul) /* +4.0553869862e-17 */ ,
    floatFromBits(0x3FD35410C2E18152ul) /* +3.0200594932e-01 */ ,
    floatFromBits(0xBC73CB002F96E062ul) /* -1.7167666235e-17 */ ,
    floatFromBits(0x3FEE817BAB4CD10Dul) /* +9.5330604035e-01 */ ,
    floatFromBits(0xBC7D0AFE686B5E0Aul) /* -2.5190738780e-17 */ ,
    floatFromBits(0x3FD4135C94176601ul) /* +3.1368174040e-01 */ ,
    floatFromBits(0x3C70C97C4AFA2518ul) /* +1.4560447300e-17 */ ,
    floatFromBits(0x3FEE6288EC48E112ul) /* +9.4952818059e-01 */ ,
    floatFromBits(0xBC616B56F2847754ul) /* -7.5544151928e-18 */ ,
    floatFromBits(0x3FD4D1E24278E76Aul) /* +3.2531029216e-01 */ ,
    floatFromBits(0x3C62417218792858ul) /* +7.9171249464e-18 */ ,
    floatFromBits(0x3FEE426A4B2BC17Eul) /* +9.4560732538e-01 */ ,
    floatFromBits(0x3C8A873889744882ul) /* +4.6019102479e-17 */ ,
    floatFromBits(0x3FD58F9A75AB1FDDul) /* +3.3688985339e-01 */ ,
    floatFromBits(0xBC1EFDC0D58CF620ul) /* -4.2000940033e-19 */ ,
    floatFromBits(0x3FEE212104F686E5ul) /* +9.4154406518e-01 */ ,
    floatFromBits(0xBC8014C76C126527ul) /* -2.7896379548e-17 */ ,
    floatFromBits(0x3FD64C7DDD3F27C6ul) /* +3.4841868025e-01 */ ,
    floatFromBits(0x3C510D2B4A664121ul) /* +3.6974420514e-18 */ ,
    floatFromBits(0x3FEDFEAE622DBE2Bul) /* +9.3733901191e-01 */ ,
    floatFromBits(0xBC8514EA88425567ul) /* -3.6570926284e-17 */ ,
    floatFromBits(0x3FD7088530FA459Ful) /* +3.5989503653e-01 */ ,
    floatFromBits(0xBC744B19E0864C5Dul) /* -1.7601687124e-17 */ ,
    floatFromBits(0x3FEDDB13B6CCC23Cul) /* +9.3299279883e-01 */ ,
    floatFromBits(0x3C883C37C6107DB3ul) /* +4.2041415555e-17 */ ,
    floatFromBits(0x3FD7C3A9311DCCE7ul) /* +3.7131719395e-01 */ ,
    floatFromBits(0x3C19A3F21EF3E8D9ul) /* +3.4749239648e-19 */ ,
    floatFromBits(0x3FEDB6526238A09Bul) /* +9.2850608047e-01 */ ,
    floatFromBits(0xBC7ADEE7EAE69460ul) /* -2.3306639848e-17 */ ,
    floatFromBits(0x3FD87DE2A6AEA963ul) /* +3.8268343236e-01 */ ,
    floatFromBits(0xBC672CEDD3D5A610ul) /* -1.0050772696e-17 */ ,
    floatFromBits(0x3FED906BCF328D46ul) /* +9.2387953251e-01 */ ,
    floatFromBits(0x3C7457E610231AC2ul) /* +1.7645047084e-17 */ ,
    floatFromBits(0x3FD9372A63BC93D7ul) /* +3.9399204006e-01 */ ,
    floatFromBits(0x3C6684319E5AD5B1ul) /* +9.7649241641e-18 */ ,
    floatFromBits(0x3FED696173C9E68Bul) /* +9.1911385169e-01 */ ,
    floatFromBits(0xBC7E8C61C6393D55ul) /* -2.6496484622e-17 */ ,
    floatFromBits(0x3FD9EF7943A8ED8Aul) /* +4.0524131400e-01 */ ,
    floatFromBits(0x3C66DA81290BDBABul) /* +9.9111401943e-18 */ ,
    floatFromBits(0x3FED4134D14DC93Aul) /* +9.1420975570e-01 */ ,
    floatFromBits(0xBC84EF5295D25AF2ul) /* -3.6316182528e-17 */ ,
    floatFromBits(0x3FDAA6C82B6D3FCAul) /* +4.1642956010e-01 */ ,
    floatFromBits(0xBC7D5F106EE5CCF7ul) /* -2.5475580413e-17 */ ,
    floatFromBits(0x3FED17E7743E35DCul) /* +9.0916798309e-01 */ ,
    floatFromBits(0xBC5101DA3540130Aul) /* -3.6878564091e-18 */ ,
    floatFromBits(0x3FDB5D1009E15CC0ul) /* +4.2755509343e-01 */ ,
    floatFromBits(0x3C65B362CB974183ul) /* +9.4111898163e-18 */ ,
    floatFromBits(0x3FECED7AF43CC773ul) /* +9.0398929312e-01 */ ,
    floatFromBits(0xBC5E7B6BB5AB58AEul) /* -6.6097544687e-18 */ ,
    floatFromBits(0x3FDC1249D8011EE7ul) /* +4.3861623854e-01 */ ,
    floatFromBits(0xBC7813AABB515206ul) /* -2.0883315831e-17 */ ,
    floatFromBits(0x3FECC1F0F3FCFC5Cul) /* +8.9867446569e-01 */ ,
    floatFromBits(0x3C7E57613B68F6ABul) /* +2.6316906461e-17 */ ,
    floatFromBits(0x3FDCC66E9931C45Eul) /* +4.4961132965e-01 */ ,
    floatFromBits(0x3C56850E59C37F8Ful) /* +4.8831924232e-18 */ ,
    floatFromBits(0x3FEC954B213411F5ul) /* +8.9322430120e-01 */ ,
    floatFromBits(0xBC52FB761E946603ul) /* -4.1161239152e-18 */ ,
    floatFromBits(0x3FDD79775B86E389ul) /* +4.6053871096e-01 */ ,
    floatFromBits(0x3C7550EC87BC0575ul) /* +1.8488777492e-17 */ ,
    floatFromBits(0x3FEC678B3488739Bul) /* +8.8763962040e-01 */ ,
    floatFromBits(0x3C6D86CAC7C5FF5Bul) /* +1.2805091919e-17 */ ,
    floatFromBits(0x3FDE2B5D3806F63Bul) /* +4.7139673683e-01 */ ,
    floatFromBits(0x3C5E0D891D3C6841ul) /* +6.5166781361e-18 */ ,
    floatFromBits(0x3FEC38B2F180BDB1ul) /* +8.8192126435e-01 */ ,
    floatFromBits(0xBC76E0B1757C8D07ul) /* -1.9843248406e-17 */ ,
    floatFromBits(0x3FDEDC1952EF78D6ul) /* +4.8218377208e-01 */ ,
    floatFromBits(0xBC7DD0F7C33EDEE6ul) /* -2.5861500926e-17 */ ,
    floatFromBits(0x3FEC08C426725549ul) /* +8.7607009420e-01 */ ,
    floatFromBits(0x3C5B157FD80E2946ul) /* +5.8729024235e-18 */ ,
    floatFromBits(0x3FDF8BA4DBF89ABAul) /* +4.9289819223e-01 */ ,
    floatFromBits(0xBC32EC1FC1B776B8ul) /* -1.0257831677e-18 */ ,
    floatFromBits(0x3FEBD7C0AC6F952Aul) , /* +8.7008699111e-01 */
    floatFromBits(0xBC8825A732AC700Aul) , /* -4.1888510869e-17 */
    floatFromBits(0x3FE01CFC874C3EB7ul) , /* +5.0353838373e-01 */
    floatFromBits(0xBC734A35E7C2368Cul) , /* -1.6731308205e-17 */
    floatFromBits(0x3FEBA5AA673590D2ul) , /* +8.6397285612e-01 */
    floatFromBits(0x3C87EA4E370753B6ul) , /* +4.1486355957e-17 */
    floatFromBits(0x3FE073879922FFEEul) , /* +5.1410274419e-01 */
    floatFromBits(0xBC8A5A014347406Cul) , /* -4.5712707524e-17 */
    floatFromBits(0x3FEB728345196E3Eul) , /* +8.5772861000e-01 */
    floatFromBits(0xBC8BC69F324E6D61ul) , /* -4.8183447936e-17 */
    floatFromBits(0x3FE0C9704D5D898Ful) , /* +5.2458968268e-01 */
    floatFromBits(0xBC88D3D7DE6EE9B2ul) , /* -4.3068869040e-17 */
    floatFromBits(0x3FEB3E4D3EF55712ul) , /* +8.5135519311e-01 */
    floatFromBits(0xBC8EB6B8BF11A493ul) , /* -5.3279874446e-17 */
    floatFromBits(0x3FE11EB3541B4B23ul) , /* +5.3499761989e-01 */
    floatFromBits(0xBC8EF23B69ABE4F1ul) , /* -5.3683132708e-17 */
    floatFromBits(0x3FEB090A58150200ul) , /* +8.4485356525e-01 */
    floatFromBits(0xBC8926DA300FFCCEul) , /* -4.3631360297e-17 */
    floatFromBits(0x3FE1734D63DEDB49ul) , /* +5.4532498842e-01 */
    floatFromBits(0xBC87EEF2CCC50575ul) , /* -4.1517817538e-17 */
    floatFromBits(0x3FEAD2BC9E21D511ul) , /* +8.3822470555e-01 */
    floatFromBits(0xBC847FBE07BEA548ul) , /* -3.5560085053e-17 */
    floatFromBits(0x3FE1C73B39AE68C8ul) , /* +5.5557023302e-01 */
    floatFromBits(0x3C8B25DD267F6600ul) , /* +4.7094109406e-17 */
    floatFromBits(0x3FEA9B66290EA1A3ul) , /* +8.3146961230e-01 */
    floatFromBits(0x3C39F630E8B6DAC8ul) , /* +1.4073856985e-18 */
    floatFromBits(0x3FE21A799933EB59ul) , /* +5.6573181078e-01 */
    floatFromBits(0xBC83A7B177C68FB2ul) , /* -3.4096079597e-17 */
    floatFromBits(0x3FEA63091B02FAE2ul) , /* +8.2458930278e-01 */
    floatFromBits(0xBC7E911152248D10ul) , /* -2.6512360489e-17 */
    floatFromBits(0x3FE26D054CDD12DFul) , /* +5.7580819142e-01 */
    floatFromBits(0xBC85DA743EF3770Cul) , /* -3.7909495459e-17 */
    floatFromBits(0x3FEA29A7A0462782ul) , /* +8.1758481315e-01 */
    floatFromBits(0xBC7128BB015DF175ul) , /* -1.4883149812e-17 */
    floatFromBits(0x3FE2BEDB25FAF3EAul) , /* +5.8579785746e-01 */
    floatFromBits(0xBC514981C796EE46ul) , /* -3.7485501964e-18 */
    floatFromBits(0x3FE9EF43EF29AF94ul) , /* +8.1045719825e-01 */
    floatFromBits(0x3C7B1DFCB60445C2ul) , /* +2.3520367350e-17 */
    floatFromBits(0x3FE30FF7FCE17035ul) , /* +5.9569930449e-01 */
    floatFromBits(0xBC6EFCC626F74A6Ful) , /* -1.3438641937e-17 */
    floatFromBits(0x3FE9B3E047F38741ul) , /* +8.0320753148e-01 */
    floatFromBits(0xBC830EE286712474ul) , /* -3.3060609805e-17 */
    floatFromBits(0x3FE36058B10659F3ul) , /* +6.0551104140e-01 */
    floatFromBits(0xBC81FCB3A35857E7ul) , /* -3.1202672493e-17 */
    floatFromBits(0x3FE9777EF4C7D742ul) , /* +7.9583690461e-01 */
    floatFromBits(0xBC815479A240665Eul) , /* -3.0062724852e-17 */
    floatFromBits(0x3FE3AFFA292050B9ul) , /* +6.1523159058e-01 */
    floatFromBits(0x3C7E3E25E3954964ul) , /* +2.6231417767e-17 */
    floatFromBits(0x3FE93A22499263FBul) , /* +7.8834642763e-01 */
    floatFromBits(0x3C83D419A920DF0Bul) , /* +3.4396993154e-17 */
    floatFromBits(0x3FE3FED9534556D4ul) , /* +6.2485948814e-01 */
    floatFromBits(0x3C836916608C5061ul) , /* +3.3671846037e-17 */
    floatFromBits(0x3FE8FBCCA3EF940Dul) , /* +7.8073722857e-01 */
    floatFromBits(0xBC66DFA99C86F2F1ul) , /* -9.9198782067e-18 */
    floatFromBits(0x3FE44CF325091DD6ul) , /* +6.3439328416e-01 */
    floatFromBits(0x3C68076A2CFDC6B3ul) , /* +1.0420901929e-17 */
    floatFromBits(0x3FE8BC806B151741ul) , /* +7.7301045336e-01 */
    floatFromBits(0xBC82C5E12ED1336Dul) , /* -3.2565907034e-17 */
    floatFromBits(0x3FE49A449B9B0939ul) , /* +6.4383154289e-01 */
    floatFromBits(0xBC827EE16D719B94ul) , /* -3.2084798795e-17 */
    floatFromBits(0x3FE87C400FBA2EBFul) , /* +7.6516726562e-01 */
    floatFromBits(0xBC82DABC0C3F64CDul) , /* -3.2707225613e-17 */
    floatFromBits(0x3FE4E6CABBE3E5E9ul) , /* +6.5317284295e-01 */
    floatFromBits(0x3C63C293EDCEB327ul) , /* +8.5695642060e-18 */
    floatFromBits(0x3FE83B0E0BFF976Eul) , /* +7.5720884651e-01 */
    floatFromBits(0xBC76F420F8EA3475ul) , /* -1.9909098777e-17 */
    floatFromBits(0x3FE5328292A35596ul) , /* +6.6241577759e-01 */
    floatFromBits(0xBC7A12EB89DA0257ul) , /* -2.2615508886e-17 */
    floatFromBits(0x3FE7F8ECE3571771ul) , /* +7.4913639452e-01 */
    floatFromBits(0xBC89C8D8CE93C917ul) , /* -4.4729078447e-17 */
    floatFromBits(0x3FE57D69348CECA0ul) , /* +6.7155895485e-01 */
    floatFromBits(0xBC875720992BFBB2ul) , /* -4.0489037749e-17 */
    floatFromBits(0x3FE7B5DF226AAFAFul) , /* +7.4095112535e-01 */
    floatFromBits(0xBC70F537ACDF0AD7ul) , /* -1.4708616952e-17 */
    floatFromBits(0x3FE5C77BBE65018Cul) , /* +6.8060099780e-01 */
    floatFromBits(0x3C8069EA9C0BC32Aul) , /* +2.8473293355e-17 */
    floatFromBits(0x3FE771E75F037261ul) , /* +7.3265427167e-01 */
    floatFromBits(0x3C75CFCE8D84068Ful) , /* +1.8918673482e-17 */
    floatFromBits(0x3FE610B7551D2CDFul) , /* +6.8954054474e-01 */
    floatFromBits(0xBC7251B352FF2A37ul) , /* -1.5889323295e-17 */
    floatFromBits(0x3FE72D0837EFFF96ul) , /* +7.2424708295e-01 */
    floatFromBits(0x3C80D4EF0F1D915Cul) , /* +2.9198471334e-17 */
    floatFromBits(0x3FE6591925F0783Dul) , /* +6.9837624941e-01 */
    floatFromBits(0x3C8C3D64FBF5DE23ul) , /* +4.8988282436e-17 */
    floatFromBits(0x3FE6E74454EAA8AFul) , /* +7.1573082528e-01 */
    floatFromBits(0xBC8DBC03C84E226Eul) , /* -5.1581018476e-17 */
    floatFromBits(0x3FE6A09E667F3BCDul) , /* +7.0710678119e-01 */
    floatFromBits(0xBC8BDD3413B26456ul) , /* -4.8336466567e-17 */
    floatFromBits(0x3FE6A09E667F3BCDul) , /* +7.0710678119e-01 */
    floatFromBits(0xBC8BDD3413B26456ul) , /* -4.8336466567e-17 */
);

/*

How these functions work:

The trig range reduction in crlibm computes an integer k and a reduced
argument y such that

x = k.Pi/256 + y

with the reduced argument y directly in -Pi/512, Pi/512.
(Pi/512 < 4/512 = 2^-7)
y is computed as a double-double yh+yl

Then we read off a table

  sah+sal ~ sin(kPi/256)
  cah+cal ~ cos(kPi/256)

and we use the reconstruction

  sin(kPi/256 + y) = sin(kPi/256)cos(y) + cos(kPi/256)sin(y)
  cos(kPi/256 + y) = cos(kPi/256)cos(y) - sin(kPi/256)sin(y)

where cos(y) and sin(y) are computed as unevaluated 1+tc and (yh+yl)(1+ts)
respectively, where tc and ts are doubles resulting from a small
polynomial approximation.
This gives 14 extra bits of accuracy, so this first step is very accurate.


Why not use accurate tables as defined by Gal ?

In short, because Gal's fast approach only gives as many additiona bits
as you've got to address the table (so we are limited to 7 if we limit
the table size to 4KB), and we need more to have a good average performance.
From a performance point of view we probably lose a few cycles: There
is 4 values to read in our scheme compared to 3 in Gal's method. The
reconstruction costs a few floating-point operations more (not that
many, if you look in details and want to ensure more than 7 extra
bits).

Now for the advantages:
1/ The whole thing is simpler
2/ We have much more accuracy in the table, which simplifies the proof.
3/ We will be able to reuse the same table values to speed up the
second step (just tabulating a third double such that the three-double
approx of sin/cos(kPi/256) will be summed exactly into an SCS number)



Now a word on range reduction:

We have 4 possible range reductions:

Cody and Waite with 2 constants (the fastest)
Cody and Waite with 3 constants (almost as fast)
Cody and Waite with 3 constants in double-double and k a long-long int
Payne and Hanek, implemented in SCS (the slowest).

Each of these range reductions except Payne and Hanek is valid for x
smaller than some bound.

This range reduction may cancel up to 62 bits according to a program
by Kahan/Douglas available in Muller's book and implemented as
function WorstCaseForAdditiveRangeReduction in common-procedures.mpl
However this is not a concern unless x is close to a multiple of Pi/2
(that is k&127==0): in the general case the reconstruction will add a
tabulated non-zero value, so the error to consider in the range
reduction is the absolute error. Only in the cases when k&127==0 do we
need to have 62 extra bits to compute with. This is ensured by using a
slower, more accurate range reduction. This test for k&127==0 actually
speeds up even these cases, because in these cases there is no table
to read and no reconstruction to do : a simple approximation to the
function suffices.


Why not use Payne and Hanek only as in Markstein's book ?  Because
our scheme, in the absence of FMA, is much faster for small values
which are the most used.

Markstein takes as reduced argument the fractional part of x*256/Pi,
(or maybe it's 512 in his case), so he's got the same tables as we have,
but different polynomials (which compute sin(2Pi*y) and cos(2Pi*y).

 */


/* TODO:


 - In some Cody and Waite there are Mul12 involving k, CH and CM. They
	 can be improved by pre-splitting CH, CM (tabulated values)
	 and k (as an int) Then you can improve the precision by
	 taking kmax into account

 - The first coefficient of the cosine polynomial is equal exactly
   to 1/2 and this should be modified in order to increase to accuracy
   of the approximation.

 - The second step should get the reduced argument from the first step
   (and use the same argument reduction). This should lead to 5x
   improvement of the worst case.

 - in the tangent there are three steps. This could be studied for the
   other functions
*/

private inline rem_pio256_scs(result,x){
    var r,tmp = Array[UInt64,SCS_NB_WORDS+3](), 0ul;

    /* result r[0],...,r[10] could store till 300 bits of precision */
    /* that is really enough for computing the reduced argument */

    if (x.excp.1 != 1 or x.index < -2){
        scs_set(result,x);
        return 0;
    }
    /* Compute the product |x| * 256/Pi */
    if (x.index == -2){
        r[0] =  0ul;
        r[1] =  0ul;
        r[2] =  digits_256_over_pi[0] * x.h_word[0];
        r[3] =  digits_256_over_pi[0] * x.h_word[1]+digits_256_over_pi[1] * x.h_word[0];
        if(x.h_word[2] == 0){
            for(i in range(4,SCS_NB_WORDS+3)){
                r[i] = digits_256_over_pi[i-3] * x.h_word[1]
                +digits_256_over_pi[i-2] * x.h_word[0];
            }
        } else {
            for(i in range(4,SCS_NB_WORDS+3)){
                r[i] = digits_256_over_pi[i-4] * x.h_word[2]
                +digits_256_over_pi[i-3] * x.h_word[1]
                +digits_256_over_pi[i-2] * x.h_word[0];
            }
        }
    } else {
        if (x.index == -1){
            r[0] =  0;
            r[1] = digits_256_over_pi[0] * x.h_word[0];
            r[2] = digits_256_over_pi[0] * x.h_word[1]
            +digits_256_over_pi[1] * x.h_word[0];
            if(x.h_word[2] == 0){
                for(i in range(3,SCS_NB_WORDS+3)){
                    r[i] = digits_256_over_pi[i-2] * x.h_word[1]
                    +digits_256_over_pi[i-1] * x.h_word[0];
                }
            }else {
                for(i in range(3,SCS_NB_WORDS+3)){
                    r[i] = digits_256_over_pi[i-3] * x.h_word[2]
                    +digits_256_over_pi[i-2] * x.h_word[1]
                    +digits_256_over_pi[i-1] * x.h_word[0];
                }
            }
        } else {
            if (x.index == 0){
                r[0] = digits_256_over_pi[0] * x.h_word[0];
                r[1] = digits_256_over_pi[0] * x.h_word[1]
                +digits_256_over_pi[1] * x.h_word[0];
                if(x.h_word[2] == 0){
                    for(i in range(2,SCS_NB_WORDS+3)){
                        r[i] = digits_256_over_pi[i-1] * x.h_word[1]
                        +digits_256_over_pi[ i ] * x.h_word[0];
                    }
                } else {
                    for(i in range(2,SCS_NB_WORDS+3)){
                        r[i] = digits_256_over_pi[i-2] * x.h_word[2]
                        +digits_256_over_pi[i-1] * x.h_word[1]
                        +digits_256_over_pi[ i ] * x.h_word[0];
                    }
                }
            }else {
                if (x.index == 1){
                    r[0] = digits_256_over_pi[0] * x.h_word[1]
                    +digits_256_over_pi[1] * x.h_word[0];
                    if(x.h_word[2] == 0){
                        for(i in range(1,SCS_NB_WORDS+3)){
                            r[i] = digits_256_over_pi[i] * x.h_word[1]
                            +digits_256_over_pi[i+1] * x.h_word[0];
                        }
                    }else {
                        for(i in range(1,SCS_NB_WORDS+3)){
                            r[i] = digits_256_over_pi[i-1] * x.h_word[2]
                            +digits_256_over_pi[ i ] * x.h_word[1]
                            +digits_256_over_pi[i+1] * x.h_word[0];
                        }
                    }
                } else {
                    var ind = (x.index - 2);
                    var digits_256_over_pi_pt = Pointer[Int](&digits_256_over_pi[ind]);
                    if(x.h_word[2] == 0){
                        for(i in range(SCS_NB_WORDS+3)){
                            r[i] = digits_256_over_pi_pt[i+1] * x.h_word[1]
                            +digits_256_over_pi_pt[i+2] * x.h_word[0];
                        }
                    }else {
                        for(i in range(SCS_NB_WORDS+3)){
                            r[i] = digits_256_over_pi_pt[i] * x.h_word[2]
                            +digits_256_over_pi_pt[i+1] * x.h_word[1]
                            +digits_256_over_pi_pt[i+2] * x.h_word[0];
                        }
                    }
                }
            }
        }
    }

    /* Carry propagate */
    r[SCS_NB_WORDS+1] += bitshr(r[SCS_NB_WORDS+2],30);
    for(i in reverseRange(SCS_NB_WORDS+1,1)) {
        tmp=bitshr(r[i],30);
        r[i-1] += tmp;
        r[i] -= bitshl(tmp,30);
    }
    /* The integer part is in r[0] */
    var N,sign = r[0],0;

    if(r[1] > SCS_RADIX/2){	/* test if the reduced part is bigger than Pi/4 */
        N += 1;
        sign = -1;
        for(i in range(1,SCS_NB_WORDS+3))
            r[i] = bitand(bitnot(r[i]),0x3fffffff);
    }
    else
        sign = 1;

    /* Now we get the reduced argument and check for possible
    * cancellation. By Kahan algorithm we will have at most 2 digits
    * of cancellations, r[1] and r[2] in the worst case.
    */
    var i = 0;
    if(r[1] == 0)
        if(r[2] == 0)
            i = 3;
        else
            i = 2;
    else
        i = 1;

    for(j in range(SCS_NB_WORDS))
        result.h_word[j] = UInt32(r[i+j]);

    result.excp.1 = 1;
    result.index = -i;
    result.sign = sign*x.sign;

    /* Last step :
    *   Multiplication by pi/2
    */
    scs_mul(result, Pio256, result);
    return Int(N*x.sign);
}



/************************************************************************/
/*                                                                      */
/*                       Argument Reduction                             */
/*                                                                      */
/************************************************************************/

var SHIFT1 = 1. / Double(bitshl(1,SCS_NB_BITS));
var SHIFT2 = SHIFT1*SHIFT1;
var SHIFT3 = SHIFT2*SHIFT1;

private inline RangeReductionSCS(rri) --> k:Int,index:Int,quadrant:Int,yh:Double,yl:Double {
    var nb = db_number();
    var X, Y = scs(),scs();
    scs_set_d(X,rri.x);
    k <-- rem_pio256_scs(Y, X);
    index <-- bitshl(bitand(k,127),2);
    quadrant <-- bitand(bitshr(k,7),3);
    var x0 = Double(Y.h_word[0]);
    var x1 = Double(Y.h_word[1]) * SHIFT1;
    var x2 = Double(Y.h_word[2]) * SHIFT2;
    var x3 = Double(Y.h_word[3]) * SHIFT3;
    nb.0[1] = bitshl(Y.index*SCS_NB_BITS + 1023 , 20);
    nb.0[0] = 0;
    nb.2 *= Y.sign;
    yh <-- ((x2+x1)+x0) * nb.2;
    yl <-- ((((x0-yh)+x1)+x2) + x3) * nb.2;
//     yh *= nb.2;     /* exact multiplication */
//     yl *= nb.2;     /* exact multiplication */
}



record rrinfo (rh:Double,rl:Double,x:Double,absxhi:Int,function:Int);

private inline computeZero(rri,quadrant,yh,yl):{
    alias ZERO = 0.;
    var DoSinZero = () -> {
        var yh2 = yh*yh ;
        var ts = yh2 * (s3 + yh2*(s5 + yh2*s7));
        return ..Add12( yh, yl+ts*yh);
    };

    var DoCosZero = () -> {
        var yh2 = yh*yh ;
        var tc = yh2 * (c2 + yh2*(c4 + yh2*c6 ));
        return ..Add12( 1., tc);
    };

    switch(rri.function)
        case (SIN){
            if (bitand(quadrant,1)!=0)
                rri.rh, rri.rl = DoCosZero();
            else
                rri.rh, rri.rl = DoSinZero();
            rri.function = if(quadrant==2 or quadrant==3) 1 else 0;
            return;
        }
        case (COS){
            if (bitand(quadrant,1)!=0)
                rri.rh, rri.rl = DoSinZero();
            else
                rri.rh, rri.rl = DoCosZero();
            rri.function = if(quadrant==1 or quadrant==2) 1 else 0;
            return;
        }
        case (TAN){
            rri.function = Int(bitand(quadrant,1));
            var ch,cl,sh,sl = ZERO,ZERO,ZERO,ZERO;
            if (bitand(quadrant,1) != 0) {
                ch, cl = DoSinZero();
                sh, sl = DoCosZero();
            } else {
                sh, sl = DoSinZero();
                ch, cl = DoCosZero();
            }
            rri.rh, rri.rl = Div22( sh, sl, ch, cl);
            return;
        }
}

private inline computeNotZero(rri,index,quadrant,yh,yl):{
    alias ZERO = 0.;
    var sah,sal,cah,cal = ZERO,ZERO,ZERO,ZERO;
    if(index <= bitshl(64,2)) {
        sah = sincosTable[index+0]; /* sin(a), high part */
        sal = sincosTable[index+1]; /* sin(a), low part  */
        cah = sincosTable[index+2]; /* cos(a), high part */
        cal = sincosTable[index+3]; /* cos(a), low part  */
    }else { /* cah <= sah */
        index = bitshl(128,2) - index;
        cah = sincosTable[index+0]; /* cos(a), high part */
        cal = sincosTable[index+1]; /* cos(a), low part  */
        sah = sincosTable[index+2]; /* sin(a), high part */
        sal = sincosTable[index+3]; /* sin(a), low part  */
    }
    var yh2 = yh*yh ;
    var ts = yh2 * (s3 + yh2*(s5 + yh2*s7));
    var tc = yh2 * (c2 + yh2*(c4 + yh2*c6 ));

    var DoSinNotZero = () -> {
        var cahyh_h,cahyh_l = Mul12( cah, yh);
        var thi, tlo = Add12( sah,cahyh_h);
        tlo = tc*sah+(ts*cahyh_h+(sal+(tlo+(cahyh_l+(cal*yh + cah*yl))))) ;
        return ..Add12( thi, tlo);
    };

    var DoCosNotZero = ()-> {
        var sahyh_h,sahyh_l = Mul12( sah, yh);
        var thi, tlo = Add12(  cah, -sahyh_h);
        tlo = tc*cah-(ts*sahyh_h-(cal+(tlo-(sahyh_l+(sal*yh+sah*yl))))) ;
        return ..Add12(   thi, tlo);
    };
    switch(rri.function)

        case (SIN){
            if (bitand(quadrant,1)==1)
                rri.rh, rri.rl = DoCosNotZero();
            else
                rri.rh, rri.rl = DoSinNotZero();
            rri.function = if(quadrant==2 or quadrant==3) 1 else 0;
            return;
        }
        case (COS){
            if (bitand(quadrant,1)==1)
                rri.rh, rri.rl = DoSinNotZero();
            else
                rri.rh, rri.rl = DoCosNotZero();
            rri.function = if(quadrant==1 or quadrant==2) 1 else 0;
            return;
        }
        case (TAN){
            rri.function = Int(bitand(quadrant,1));
            var ch,cl,sh,sl = ZERO,ZERO,ZERO,ZERO;
            if (bitand(quadrant,1)==1) {
                ch, cl = DoSinNotZero();
                sh, sl = DoCosNotZero();
            } else {
                sh, sl = DoSinNotZero();
                ch, cl = DoCosNotZero();
            }
            rri.rh, rri.rl = Div22(sh, sl, ch, cl);
            return;
        }
}

private inline ComputeTrigWithArgred(rri):{
    alias ZERO = 0.;
    var yh,yl,th,tl = ZERO,ZERO,ZERO,ZERO;
    var kl,k,kd,quadrant,index = 0l,0,ZERO,0l,0l;

    if(rri.absxhi < XMAX_CODY_WAITE_3) {
        /* Compute k, deduce the table index and the quadrant */
        k = DOUBLE2INT( rri.x * INV_PIO256);
        kd = Double(k);
        quadrant = bitand(bitshr(k,7),3);
        index = bitshl(bitand(k,127),2);
        if(index == 0) {
            /* Here a large cancellation on yh+yl would be a problem, so use double-double RR */
            /* all this is exact */
            var kch_h, kch_l = Mul12( kd, RR_DD_MCH);
            var kcm_h, kcm_l = Mul12(  kd, RR_DD_MCM);
            th,tl = Add12 ( kch_l, kcm_h) ;
            /* only rounding error in the last multiplication and addition */
            yh, yl = Add22 (rri.x + kch_h , kcm_l - kd*RR_DD_CL, th, tl);
            computeZero(rri,quadrant,yh,yl);
        }
        else {
            /* index <> 0, don't worry about cancellations on yh+yl */
            if (rri.absxhi < XMAX_CODY_WAITE_2) {
                /* CW 2: all this is exact but the rightmost multiplication */
                yh,yl = Add12(rri.x - kd*RR_CW2_CH, kd*RR_CW2_MCL);
            }
            else {
                /* CW 3: all this is exact but the rightmost multiplication */
                yh,yl = Add12Cond((rri.x - kd*RR_CW3_CH) -  kd*RR_CW3_CM,   kd*RR_CW3_MCL);
            }
            computeNotZero(rri,index,quadrant,yh,yl);
        }

    }

    else if ( rri.absxhi < XMAX_DDRR ) {
        /* x sufficiently small for a Cody and Waite in double-double */
        kl = DOUBLE2LONGINT( rri.x*INV_PIO256);
        kd = Double(kl);
        quadrant = bitand(bitshr(kl,7),3);
        index = bitshl(bitand(kl,127),2);
        if(index == 0) {
            /* Here again a large cancellation on yh+yl would be a problem,
            so we do the accurate range reduction */
            k,index,quadrant,yh,yl = RangeReductionSCS(rri);   /*recomputes k, index, quadrant, and yh and yl*/
            /* Now it may happen that the new k differs by 1 of kl, so check that */
            if(index == 0)   /* no surprise */
                computeZero(rri,quadrant,yh,yl);
            else
                computeNotZero(rri,index,quadrant,yh,yl);
        }
        else {   /*  index<>0 : double-double argument reduction*/
            /* all this is exact */
            var kch_h, kch_l = Mul12(   kd, RR_DD_MCH);
            var kcm_h, kcm_l = Mul12(  kd, RR_DD_MCM);
            th,tl = Add12 ( kch_l, kcm_h) ;
            /* only rounding error in the last multiplication and addition */
            yh,yl = Add22(rri.x + kch_h, kcm_l - kd*RR_DD_CL, th, tl);
            //      printf("%f\n", yh);
            computeNotZero(rri,index,quadrant,yh,yl);
        }
    } /* closes if ( absxhi < XMAX_DDRR ) */
    else {
        /* Worst case : x very large, sin(x) probably meaningless, we return
        correct rounding but do't mind taking time for it */
        k,index,quadrant,yh,yl = RangeReductionSCS(rri);
        quadrant = bitand(bitshr(k,7),3);
        if(index == 0)
            computeZero(rri,quadrant,yh,yl);
        else
            computeNotZero(rri,index,quadrant,yh,yl);
    }

}


private inline sin_rn(x:Double) --> r:Double {
    var rri = rrinfo(0.,0.,0.,0,0);
    var x_split = db_number();

    x_split.2 = x;
    rri.absxhi = bitand(x_split.0[1] , 0x7fffffff);

    /* SPECIAL CASES: x=(Nan, Inf) sin(x)=Nan */
    if (rri.absxhi >= 0x7ff00000)
        r <-- nan(Double);
    else if (rri.absxhi < XMAX_SIN_CASE2){
        /* CASE 1 : x small enough sin(x)=x */
        if (rri.absxhi < XMAX_RETURN_X_FOR_SIN){
            r <-- x;
        }
        else {
            /* CASE 2 :XMAX_RETURN_X_FOR_SIN x < XMAX_SIN_CASE2
            Fast polynomial evaluation as in DoSinZero */
            var x2 = x*x ;
            var ts = x2 * (s3 + x2*(s5 + x2*s7));
            rri.rh,rri.rl = Add12(x, ts*x);
            if(rri.rh == (rri.rh + (rri.rl * RN_CST_SIN_CASE2)))
                r <-- rri.rh;
            else{
//                 println("Worst case correct rounding not yet implemented.");
                r <-- scs_sin_rn(x);
            }
        }
    }

    /* CASE 3 : Need argument reduction */
    else {
        rri.x = x;
        rri.function = SIN;
        ComputeTrigWithArgred(rri);

        /* change sign in parallel to the test */
        if(rri.function != 0)
            r <-- -rri.rh;
        else
            r <-- rri.rh;
        var rncst = RN_CST_SINCOS_CASE3;
        if(rri.rh != (rri.rh + (rri.rl * rncst))){
//             println("Worst case correct rounding not yet implemented.");
            r <-- scs_sin_rn(x);
        }
    }
}

private inline cos_rn(x:Double) --> r:Double {
    var rri = rrinfo ();
    var x_split = db_number();
    x_split.2 = x;
    rri.absxhi = bitand(x_split.0[1] , 0x7fffffff);

    /* SPECIAL CASES: x=(Nan, Inf) cos(x)=Nan */
    if (rri.absxhi>=0x7ff00000)
        r <-- nan(Double);
    else if (rri.absxhi < XMAX_COS_CASE2){
        /* CASE 1 : x small enough cos(x)=1. */
        if (rri.absxhi <XMAX_RETURN_1_FOR_COS_RN)
            r <-- 1.;
        else {
            /* CASE 2 : Fast polynomial evaluation */
            var x2 = x*x;
            var tc = x2 * (c2 + x2*(c4 + x2*c6 ));
            rri.rh,rri.rl = Add12( 1.0, tc);
            if(rri.rh == (rri.rh + (rri.rl * RN_CST_COS_CASE2)))
                r <-- rri.rh;
            else
                r <-- scs_cos_rn(x);
        }
    }
    else {
        /* CASE 3 : Need argument reduction */
        rri.x = x;
        rri.function = COS;
        ComputeTrigWithArgred(rri);
        if(rri.rh == (rri.rh + (rri.rl * RN_CST_SINCOS_CASE3)))
            if(rri.function != 0)
                r <-- -rri.rh;
            else
                r <-- rri.rh;
        else
            r <-- scs_cos_rn(x);
    }
}

private inline tan_rn(x:Double) --> r:Double {
    var rri = rrinfo();
    var x_split, rndcst = db_number(), db_number();
    x_split.2 = x;
    rri.absxhi = bitand(x_split.0[1] , 0x7fffffff);

    /* SPECIAL CASES: x=(Nan, Inf) cos(x)=Nan */
    if (rri.absxhi>=0x7ff00000)
        r <-- nan(Double);
    else if (rri.absxhi < XMAX_TAN_CASE2){
        if (rri.absxhi < XMAX_RETURN_X_FOR_TAN)
            r <-- x;
        else {
            /* Dynamic computation of the rounding constant */
            rndcst.0[1] = 0x3ff00000 + bitshr((bitand(rri.absxhi,0x000fffff)+0x00100000),
                                                    (0x3ff+2 - bitshr(rri.absxhi,20))) ;
            rndcst.0[0] = 0xffffffff;
            /* Fast Taylor series */
            var x2 = x*x;
            var p5 = t5 + x2*(t7 + x2*(t9 + x2*t11));
            var tt = x2*(t3h + (t3l + x2*p5));
            rri.rh, rri.rl = Add12( x, x*tt);
            /* Test if round to nearest achieved */
            if(rri.rh == (rri.rh + (rri.rl * rndcst.2)))
              r <-- rri.rh;
            else
              r <-- scs_tan_rn(x);
        }
    }
    else {
        /* Otherwise : Range reduction then standard evaluation */
        rri.x = x;
        rri.function = TAN;
        ComputeTrigWithArgred(rri);
        /* Test if round to nearest achieved */
        if(rri.rh == (rri.rh + (rri.rl * RN_CST_TAN_CASE3)))
            if(rri.function !=0 )
                r <-- -rri.rh;
            else
                r <-- rri.rh;
        else
            r <-- scs_tan_rn(x);
    }
}



[T | Float?(T)]
inline sin_safe(x:T) = T(sin_rn(Double(x)));

[T | Float?(T)]
inline cos_safe(x:T) = T(cos_rn(Double(x)));

[T | Float?(T)]
inline tan_safe(x:T) = T(tan_rn(Double(x)));

