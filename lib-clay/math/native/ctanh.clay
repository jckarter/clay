// complex tan,tanh

import math.native.kernel.ieee754.*;
import math.*;
import complex.*;

overload tanh(z:ComplexDouble) {
	
	var x,y = real(z),imagValue(z);
	var xdb = MAKE_IEEE(x);
	var ix = bitand(GET_IEEE_HIGH(xdb),0x7fffffff);

	/*
	 * ctanh(NaN + i 0) = NaN + i 0
	 *
	 * ctanh(NaN + i y) = NaN + i NaN		for y != 0
	 *
	 * The imaginary part has the sign of x*sin(2*y), but there's no
	 * special effort to get this right.
	 *
	 * ctanh(+-Inf +- i Inf) = +-1 +- 0
	 *
	 * ctanh(+-Inf + i y) = +-1 + 0 sin(2y)		for y finite
	 *
	 * The imaginary part of the sign is unspecified.  This special
	 * case is only needed to avoid a spurious invalid exception when
	 * y is infinite.
	 */
	if (ix >= 0x7ff00000) {
		if (bitor(bitand(ix,0xfffff),GET_IEEE_LOW(xdb))!=0)	/* x is NaN */
			return Complex(x, (if(y == 0) y else x * y));
		SET_IEEE_HIGH(xdb,GET_IEEE_HIGH(xdb) - 0x40000000);
		x = GET_IEEE_DB(xdb);	/* x = copysign(1, x) */
		return Complex(x, copysign(0., if(infinity?(y)) y else sin(y) * cos(y)));
	}

	/*
	 * ctanh(x + i NAN) = NaN + i NaN
	 * ctanh(x +- i Inf) = NaN + i NaN
	 */
	if (not finite?(y))
		return Complex(y - y, y - y);

	/*
	 * ctanh(+-huge + i +-y) ~= +-1 +- i 2sin(2y)/exp(2x), using the
	 * approximation sinh^2(huge) ~= exp(2*huge) / 4.
	 * We use a modified formula to avoid spurious overflow.
	 */
	if (ix >= 0x40360000) {	/* x >= 22 */
		var exp_mx = exp(-abs(x));
		return Complex(copysign(1., x),
		    4 * sin(y) * cos(y) * exp_mx * exp_mx);
	}

	/* Kahan's algorithm */
	var t = tan(y);
	var beta = 1.0 + t * t;	/* = 1 / cos^2(y) */
	var s = sinh(x);
	var rho = sqrt(1 + s * s);	/* = cosh(x) */
	var denom = 1 + beta * s * s;
	return Complex((beta * rho * s) / denom, t / denom);
}

overload tan(z:ComplexDouble) {
	/* ctan(z) = -I * ctanh(I * z) */
	var z = tanh(Complex(-imagValue(z), real(z)));
	return Complex(imagValue(z), -real(z));
}
