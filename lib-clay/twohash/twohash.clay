//
//  twohash/twohash.clay - two-hashed, unordered set/map containers
//
//  Copyright (c) 2010 Marc Fauconneau
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import twohash.implementation.*;

//
// Types
//

record HashSet[K]
(
    data: TwoHash[SetEntry[K]],
);

record HashMap[K, V]
(
    data: TwoHash[MapEntry[K, V]],
);

record SetVector[K]
(
    data: TwoHash[SetVectorEntry[K]],
    sentinel: Pointer[SetVectorEntry[K]],
);

private record SetEntry[K]
(
    key: K,
);

private record MapEntry[K, V]
(
    key: K,
    value: V,
);

private record SetVectorEntry[K]
(
    key: K,
    next: Pointer[SetVectorEntry[K]],
    prev: Pointer[SetVectorEntry[K]],
);

private define Entry?;

[T]
Entry?(#T) = false;

[K]
Entry?(#SetEntry[K]) = true;

[K, V]
Entry?(#MapEntry[K, V]) = true;

[K]
Entry?(#SetVectorEntry[K]) = true;

private define HashSetLike?;

[T, K]
HashSetLike?(#T, #K) = false;

[K]
HashSetLike?(#HashSet[K], #K) = true;

[K]
HashSetLike?(#SetVector[K], #K) = true;

//
// Type predicates
//

private define Hashtable?;

[T]
Hashtable?(#T) = false;

[T when RecordWithField?(T, "data") and TwoHash?(Type(typeToLValue(T).data))]
Hashtable?(#T) = true;

[T when Hashtable?(T)]
EntryType(#T) = EntryType(Type(typeToLValue(T).data));

//
// Entry semantics
//
// (copied from records.clay)

[T when Entry?(T)]
RegularRecord?(#T) = false;

[T when Entry?(T)]
destroy(a:T)
{ 
    ..for (x in ..recordFields(a))
        destroy(x);
}

[T when Entry?(T)]
moveUnsafe(src:T) --> returned:T {
    alias n = RecordFieldCount(T);
    ..for (i in ..staticIntegers(#n))
        fieldRefByIndex(returned, i) <-- fieldRefByIndex(src, i);
}

[T when Entry?(T)]
resetUnsafe(a:T) {
    ..for (x in ..recordFields(a))
        resetUnsafe(x);
}

//
// size
//

[Hash when Hashtable?(Hash)]
size(a: Hash) = a.data.size;

//
// lookup
//

[K, Set when HashSetLike?(Set, K)]
lookup(a: Set, key: K)
{
    var pEntry = pEntryAt(a.data, key);
    return not null(pEntry);
}

[K, V]
lookup(a: HashMap[K, V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (null?(pEntry))
        return null(V);
    return @pEntry^.value;
}

//
// put
//

[K, Set when HashSetLike?(Set, K)]
put(a: Set, key: K, b: Bool) 
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry) or not b)
    {
        if (not b) freeEntry(a.data, pEntry);
        return;
    }
    var pEntry = allocateEntryAt(a.data, key, EntryType(Set)(a, key));
}

[K, V]
put(a: HashMap[K, V], key: K, forward value: V) 
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry)) 
    {
        pEntry^.value = value;
        return;
    }
    var pEntry = allocateEntryAt(a.data, key, MapEntry[K, V](key, value));
}

//
// index
//

// !! has different semantics (non-ref return)
[K, Set when HashSetLike?(Set, K)]
index(a: Set, key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry))
        return true;
    return false;
}

[K, Set when HashSetLike?(Set, K)]
indexAssign(a: Set, key: K, b: Bool) { put(a,key,b); }

[K, V]
index(a: HashMap[K, V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry))
        return ref pEntry^.value;
    var pEntry = allocateEntryAt(a.data, key, MapEntry[K, V](key, V()));
    return ref pEntry^.value;
}

//
// remove
//

[K, Hash when Hashtable?(Hash)]
remove(a: Hash, key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (null?(pEntry))
        return false;
    freeEntry(a.data, pEntry);
    return true;
}

//
// items
//

define itemFromEntry;

[Hash when Hashtable?(Hash)]
items(a: Hash) = TwoHashEntries[EntryType(Hash), itemFromEntry](a.data);

[K]
itemFromEntry(entry: SetEntry[K]) = entry.key, true;

[K, V]
itemFromEntry(entry: MapEntry[K, V]) = entry.key, entry.value;

//
// Entry match
//

[E, K]
keyMatch?(entry: E, key: K) = entry.key == key;

[E]
entryHash(entry: E) = largeHash(entry.key);

//
// SetVector stuff
//

[K]
SetVector[K]() --> set: SetVector[K]
{
    set.data <-- TwoHash[SetVectorEntry[K]]();
    set.sentinel = allocateRawMemory(SetVectorEntry[K], 1);
    resetUnsafe(set.sentinel^.key);
    set.sentinel^.next = set.sentinel;
    set.sentinel^.prev = set.sentinel;
}

[K]
destroy(set: SetVector[K])
{
    destroy(set.data);
    destroy(set.sentinel);
}

[K]
SetVectorEntry[K](a: SetVector[K], key: K) --> entry: SetVectorEntry[K]
{
    ref sentinel = a.sentinel;
    entry.key <-- move(key);
    entry.next = sentinel;
    entry.prev = sentinel^.prev;
    entry.next^.prev = @entry;
    entry.prev^.next = @entry;
}

[K]
destroy(entry: SetVectorEntry[K])
{
    destroy(entry.key);
    entry.prev^.next = entry.next;
    entry.next^.prev = entry.prev;
}

[K]
resetUnsafe(a: SetVectorEntry[K])
{
    a.prev = @a;
    a.next = @a;
}

[K]
moveEntry(src: SetVectorEntry[K], th) --> entry: SetVectorEntry[K]
{
    entry <-- move(src);
    entry.prev^.next = @entry;
    entry.next^.prev = @entry;
}


[K]
items(a: SetVector[K]) = SetVectorItems(a.sentinel, a.sentinel);

private record SetVectorItems[K]
(
    current: Pointer[SetVectorEntry[K]],
    sentinel: Pointer[SetVectorEntry[K]],
);

[K]
iterator(i: SetVectorItems[K]) = i;

[K]
nextValue(i: SetVectorItems[K]) {
    if (i.current^.next != i.sentinel) {
        i.current = i.current^.next;
        return @i.current^.key;
    } else
        return null(Type(i.current^.key));
}

//
// misc
//

[K]
SetEntry[K](a: HashSet[K], key: K) = SetEntry[K](key);
