
import strings.cstringrefs.*;


//
// String?
//

[A]
String?(#A) = false;

[A when Sequence?(A) and (Char == SequenceElementType(A))]
overload String?(#A) = true;



//
// SizedString?
//

[A]
SizedString?(#A) = false;

[A when SizedSequence?(A) and (Char == SequenceElementType(A))]
overload SizedString?(#A) = true;



//
// ContiguousString?
//

[A]
ContiguousString?(#A) = false;

[A when ContiguousSequence?(A) and (Char == SequenceElementType(A))]
overload ContiguousString?(#A) = true;



//
// CCompatibleString?
//

[A]
CCompatibleString?(#A) = false;

[A when String?(A) and CallDefined?(cstring, A)]
overload CCompatibleString?(#A) = true;



//
// String
//

alias String = Vector[Char];



//
// construct from sequences of bytes
//

[A when Sequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
inline overload String(a:A) = String(mapped(Char, a));



//
// construct from c-string
//

[T when ByteSizedInteger?(T)]
inline overload String(cstr : Pointer[T]) = String(CStringRef(cstr));

