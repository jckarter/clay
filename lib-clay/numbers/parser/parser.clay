import libc;
import numbers.parser.errno.*;


//
// parseInt8, parseUInt8
//

[S | String?(S)]
parseInt8(s:S) = parseInt8(String(s));

[S | CCompatibleString?(S)]
overload parseInt8(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtol(p, &end, 0);
    if (end^ != 0)
        error("invalid Int8: ", s);
    if ((errno() == ERANGE) or value < Least(Int8) or value > Greatest(Int8))
        error("Int8 out of range: ", s);
    return Int8(value);
}

[S | String?(S)]
parseUInt8(s:S) = parseUInt8(String(s));

[S | CCompatibleString?(S)]
overload parseUInt8(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoul(p, &end, 0);
    if (end^ != 0)
        error("invalid UInt8: ", s);
    if ((errno() == ERANGE) or value > Greatest(UInt8))
        error("UInt8 out of range: ", s);
    return UInt8(value);
}



//
// parseInt16, parseUInt16
//

[S | String?(S)]
parseInt16(s:S) = parseInt16(String(s));

[S | CCompatibleString?(S)]
overload parseInt16(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtol(p, &end, 0);
    if (end^ != 0)
        error("invalid Int16: ", s);
    if ((errno() == ERANGE) or value < Least(Int16) or value > Greatest(Int16))
        error("Int16 out of range: ", s);
    return Int16(value);
}

[S | String?(S)]
parseUInt16(s:S) = parseUInt16(String(s));

[S | CCompatibleString?(S)]
overload parseUInt16(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoul(p, &end, 0);
    if (end^ != 0)
        error("invalid UInt16: ", s);
    if ((errno() == ERANGE) or value > Greatest(UInt16))
        error("UInt16 out of range: ", s);
    return UInt16(value);
}



//
// parseInt32, parseUInt32
//

[S | String?(S)]
parseInt32(s:S) = parseInt32(String(s));

[S | CCompatibleString?(S)]
overload parseInt32(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoll(p, &end, 0);
    if (end^ != 0)
        error("invalid Int32: ", s);
    if ((errno() == ERANGE) or (value < Least(Int32)) or (value > Greatest(Int32)))
        error("Int32 out of range: ", s);
    return Int32(value);
}

[S | String?(S)]
parseUInt32(s:S) = parseUInt32(String(s));

[S | CCompatibleString?(S)]
overload parseUInt32(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoull(p, &end, 0);
    if (end^ != 0)
        error("invalid UInt32: ", s);
    if ((errno() == ERANGE) or (value > Greatest(UInt32)))
        error("UInt32 out of range: ", s);
    return UInt32(value);
}



//
// parseInt64, parseUInt64
//

[S | String?(S)]
parseInt64(s:S) = parseInt64(String(s));

[S | CCompatibleString?(S)]
overload parseInt64(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoll(p, &end, 0);
    if (end^ != 0)
        error("invalid Int64: ", s);
    if (errno() == ERANGE)
        error("Int64 out of range: ", s);
    return Int64(value);
}

[S | String?(S)]
parseUInt64(s:S) = parseUInt64(String(s));

[S | CCompatibleString?(S)]
overload parseUInt64(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtoull(p, &end, 0);
    if (end^ != 0)
        error("invalid UInt64: ", s);
    if (errno() == ERANGE)
        error("UInt64 out of range: ", s);
    return UInt64(value);
}



//
// parseFloat32
//

[S | String?(S)]
parseFloat32(s:S) = parseFloat32(String(s));

[S | CCompatibleString?(S)]
overload parseFloat32(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtof(p, &end);
    if (end^ != 0)
        error("invalid Float32: ", s);
    if (errno() == ERANGE)
        error("Float32 out of range: ", s);
    return Float32(value);
}



//
// parseFloat64
//

[S | String?(S)]
parseFloat64(s:S) = parseFloat64(String(s));

[S | CCompatibleString?(S)]
overload parseFloat64(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtod(p, &end);
    if (end^ != 0)
        error("invalid Float64: ", s);
    if (errno() == ERANGE)
        error("Float64 out of range: ", s);
    return Float64(value);
}


//
// parseFloat80
//

[S | String?(S)]
parseFloat80(s:S) = parseFloat80(String(s));

[S | CCompatibleString?(S)]
overload parseFloat80(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtold(p, &end);
    if (end^ != 0)
        error("invalid Float80: ", s);
    if (errno() == ERANGE)
        error("Float80 out of range: ", s);
    return Float80(value);
}




//
// parseComplex32
//

[S | String?(S)]
parseComplex32(s:S) = parseComplex32(String(s));

[S | CCompatibleString?(S)]
overload parseComplex32(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtof(p, &end);
    if (end^ != 0)
        error("invalid Complex32: ", s);
    if (errno() == ERANGE)
        error("Complex32 out of range: ", s);
    return Complex32(value);
}



//
// parseComplex64
//

[S | String?(S)]
parseComplex64(s:S) = parseComplex64(String(s));

[S | CCompatibleString?(S)]
overload parseComplex64(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtod(p, &end);
    if (end^ != 0)
        error("invalid Complex64: ", s);
    if (errno() == ERANGE)
        error("Complex64 out of range: ", s);
    return Complex64(value);
}

//
// parseComplex80
//

[S | String?(S)]
parseComplex80(s:S) = parseComplex80(String(s));

[S | CCompatibleString?(S)]
overload parseComplex80(s:S) {
    var p = cstring(s);
    var end = null(CChar);
    var value = libc.strtold(p, &end);
    if (end^ != 0)
        error("invalid Complex80: ", s);
    if (errno() == ERANGE)
        error("Complex80 out of range: ", s);
    return Complex80(value);
}
