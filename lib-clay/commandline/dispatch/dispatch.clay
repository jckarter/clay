import printer.(printlnTo);
import io.files.*;
import numbers.parser.*;
import data.strings.*;
import lambdas.*;
import data.vectors.*;
import data.sequences.*;

private dispatchCommand() {
    var args = commandLine(); 
    if (size(args) < 2)
        return nothing(String), Vector[String]();
    else
        return Maybe(String(args[1])), Vector[String](mapped(String, slicedFrom(args, 2)));
}

printlnUsage(forward ..x) { printlnTo(stderr, ..x); }

private pad(actualSize, desiredSize) {
    var r = String();
    if (actualSize < desiredSize) {
        for (i in range(desiredSize - actualSize))
            push(r, ' ');
    }
    return move(r);
}

private usage(..commandTuples) {
    var longestName = foldValues(max, ..mapValues(c => size(commandName(c)), ..commandTuples));

    printlnUsage("Available commands:");
    ..for (commandTuple in commandTuples) {
        var name = commandName(commandTuple);
        printlnUsage("  ", name, pad(size(name), longestName), "    ", ..commandDescription(commandTuple));
    }

    return 2;
}


private define commandName;

[fn when CallDefined?(fn, Vector[String])]
override commandName(#fn) = StaticName(fn);

[fn, ..Description when CallDefined?(fn, Vector[String])]
override commandName(commandTuple: Tuple[Static[fn], ..Description])
    = StaticName(commandTuple.0);

[
    Name, Callable, ..Description
    when String?(Name)
      and CallDefined?(call, Callable, Vector[String])
]
override commandName(commandTuple: Tuple[Name, Callable, ..Description])
    = commandTuple.0;

private define commandFunction;

[fn when CallDefined?(fn, Vector[String])]
override commandFunction(#fn) = fn;

[fn, ..Description when CallDefined?(fn, Vector[String])]
override commandFunction(commandTuple: Tuple[Static[fn], ..Description])
    = commandTuple.0;

[
    Name, Callable, ..Description
    when String?(Name)
      and CallDefined?(call, Callable, Vector[String])
]
override commandFunction(commandTuple: Tuple[Name, Callable, ..Description])
    = commandTuple.1;

private define commandDescription;

[fn when CallDefined?(fn, Vector[String])]
override commandDescription(#fn)
    = ;

[fn, ..Description when CallDefined?(fn, Vector[String])]
override commandDescription(commandTuple: Tuple[Static[fn], ..Description])
    = ..dropValues(#1, ..unpack(commandTuple));

[
    Name, Callable, ..Description
    when String?(Name)
      and CallDefined?(call, Callable, Vector[String])
]
override commandDescription(commandTuple: Tuple[Name, Callable, ..Description])
    = ..dropValues(#2, ..unpack(commandTuple));

private commandTypeReturnCount(T)
    = countValues(..Type(..commandFunction(typeToRValue(T))(Vector[String]())));

private define invokeCommand;

[CommandTuple when commandTypeReturnCount(CommandTuple) == 1]
override invokeCommand(commandTuple: CommandTuple, args)
    = commandFunction(commandTuple)(args);

[CommandTuple when commandTypeReturnCount(CommandTuple) == 0]
override invokeCommand(commandTuple: CommandTuple, args) {
    commandFunction(commandTuple)(args);
    return 0;
}

dispatchMain(..commandTuples) {
    var maybeCmd, args = ..dispatchCommand();

    return maybe(maybeCmd, cmd => {
        ..for (commandTuple in commandTuples) {
            if (cmd == commandName(commandTuple))
                return invokeCommand(commandTuple, args);
        }
        printlnUsage("Command \"", cmd, "\" not supported");
        return usage(..commandTuples);
    }, () => usage(..commandTuples));
}

