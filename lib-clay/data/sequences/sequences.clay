
public import data.sequences.force.*;
public import data.sequences.lazy.*;
public import data.sequences.operators.*;
import data.vectors.*;


//
// strict wrappers around lazy sequences
//

define zip;
define map;
define filter;
define enumerate;
define reverse;
define slice;
define sliceFrom;
define sliceUpto;
define group;

alias override zip(..args) = force(zipped(..args));
alias override map(..args) = force(mapped(..args));
alias override filter(..args) = force(filtered(..args));
alias override enumerate(..args) = force(enumerated(..args));
alias override reverse(..args) = force(reversed(..args));
alias override slice(..args) = force(sliced(..args));
alias override sliceFrom(..args) = force(slicedFrom(..args));
alias override sliceUpto(..args) = force(slicedUpto(..args));
alias override group(..args) = force(grouped(..args));



//
// specializations for Maybe
//

[M when Maybe?(M)]
override map(f, m:M) =
    maybe(m, v -> Maybe(f(v)), () -> nothing(Type(f(just(m)))));

[T]
override filter(f, m:Maybe[T]) =
    if (just?(m) and f(just(m)))
        m
    else
        nothing(T);


// 
//
// interleave
//

[S when Sequence?(S)]
interleave(seq:S, betweenFn, fn) {
    var i = iterator(seq);
    if (var v = nextValue(i); hasValue?(v)) {
        fn(..getValue(v));
        while (v = nextValue(i); hasValue?(v)) {
            betweenFn();
            fn(..getValue(v));
        }
    }
}


[S when StaticSizedSequence?(S) and MultiValuedSequence?(S)]
alias override Array(s:S) = Array(mapped(Tuple, s));

[n, S when MultiValuedSequence?(S)]
override Array(#n, forward s:S) = Array(#n, mapped(Tuple, s));

[A when MultiValuedSequence?(A)]
override Vector(forward a:A) = Vector(mapped(Tuple, a));
