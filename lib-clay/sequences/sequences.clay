
public import sequences.force.*;
public import sequences.lazy.*;



//
// strict wrappers around lazy sequences
//

alias zip(..args) = force(zipped(..args));
alias map(..args) = force(mapped(..args));
alias filter(..args) = force(filtered(..args));
alias enumerate(..args) = force(enumerated(..args));
alias reverse(..args) = force(reversed(..args));
alias slice(..args) = force(sliced(..args));
alias sliceFrom(..args) = force(slicedFrom(..args));
alias sliceUpto(..args) = force(slicedUpto(..args));
alias group(..args) = force(grouped(..args));



//
// generic equals?, lesser?
//

[A,B when Sequence?(A) and Sequence?(B)]
overload equals?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        if (next(i) != next(j))
            return false;
    }
    return not hasNext?(j);
}

[A,B when SizedSequence?(A) and SizedSequence?(B)]
overload equals?(a:A, b:B) {
    if (size(a) != size(b))
        return false;
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}


[A,B when Sequence?(A) and Sequence?(B)]
overload lesser?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        forward x, y = next(i), next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}



//
// concatenation
//

[A, ..B when Sequence?(A) and allValues?(Sequence?,..B)
        and equalValues?(SequenceElementType(A), ..mapValues(SequenceElementType,..B))]
overload cat(forward a:A, forward ..b:B) {
    var result = Vector(a);
    push(result, ..b);
    return move(result);
}

[A, ..T when Sequence?(A) and equalValues?(SequenceElementType(A),..T)]
overload cat(forward a:A, forward ..x:T) {
    var result = Vector(a);
    push(result, x);
    return move(result);
}

[A, T when Sequence?(A) and (SequenceElementType(A) == T)]
overload cat(forward x:T, forward a:A) = Vector[T](x) ++ a;

[A, ..B when Sequence?(A) and allValues?(Sequence?,..B)
        and equalValues?(SequenceElementType(A), ..mapValues(SequenceElementType,..B))]
overload updateAssign(#cat, ref a:A, forward ..b:B) {
    push(a, ..b);
}

[A, ..T when Sequence?(A) and equalValues?(SequenceElementType(A),..T)]
overload updateAssign(#cat, forward a:A, forward ..x:T) {
    push(a, ..x);
}

[A, T when Sequence?(A) and (SequenceElementType(A) == T)]
overload updateAssign(#cat, forward x:T, forward a:A) {
    insert(a,0,x);
}

// 
//
// interleave
//

[S when Sequence?(S)]
interleave(seq:S, betweenFn, fn) {
    var i = iterator(seq);
    if (hasNext?(i)) {
        fn(..next(i));
        while (hasNext?(i)) {
            betweenFn();
            fn(..next(i));
        }
    }
}
