import unix.*;
import unix;
import io.errors.*;
import data.strings.*;
import libc;
import io.errors.*;
import io.filesystem.platform.common.*;
import data.algorithms.(reverseFind,reverseFindIf,reverseInPlace,beginsWith?,endsWith?);
import data.vectors.*;
import data.sequences.*;



readLink(x: CStringRef) {
    var path_max = pathconf(x.ptr, _PC_PATH_MAX);
    if (path_max < 0)
        path_max = 4096;

    var buf = String();
    resize(buf, path_max);

    var size = readlink(x.ptr, Pointer[CChar](begin(buf)), size_t(path_max));
    if (size < 0)
        throw GenericIOError(errno(), "readlink");

    resize(buf, size);
    return move(buf);
}

moveFile(fromPath: CStringRef, toPath: CStringRef) {
    var ok = libc.rename(fromPath.ptr, toPath.ptr);
    if (ok != 0)
        throw GenericIOError(errno(), "rename");
}

deleteFile(path: CStringRef) {
    var ok = unlink(path.ptr);
    if (ok != 0)
        throw GenericIOError(errno(), "unlink");
}





/// @section DirectoryIterator

record DirectoryIterator (
    dir : Pointer[DIR],
    dirent: Struct_dirent,
);

[S when CCompatibleString?(S)]
overload DirectoryIterator(dir: S) --> returned: DirectoryIterator {
    returned.dir = opendir(cstring(dir));
    if (null?(returned.dir))
        throw GenericIOError(errno(), "opendir");
}


overload RegularRecord?(#DirectoryIterator) = false;
overload BitwiseMovedType?(#DirectoryIterator) = true;

overload destroy(s: DirectoryIterator) {
    if (not null?(s.dir)) {
        var result = closedir(s.dir);
        assert(result != wrapCast(Type(result), -1));
    }
}
overload resetUnsafe(s: DirectoryIterator) {
    s.dir = null(DIR);
}

overload iterator(x:DirectoryIterator) = forward x;

overload nextValue(x:DirectoryIterator) {
    while (true) {
    var ptr = Pointer[Struct_dirent]();
    var returnCode = readdir_r(x.dir, @x.dirent, @ptr);
    if (returnCode != 0)
        throw GenericIOError(errno(), "readdir_r");
    if (null?(ptr))
        return nothing(DirectoryEntry);
        var name = CStringRef(begin(x.dirent.d_name));
        if (name == "." or name == "..")
            continue;
        return Maybe(DirectoryEntry(name));
    }
}



/// @section makeDirectory, deleteDirectory

makeDirectoryImpl(path: CStringRef) {
    alias oct777 = 511;
    var r = mkdir(path.ptr, mode_t(oct777));
    if (r < 0) {
        throw GenericIOError(errno(), "mkdir");
    }
}

deleteDirectoryImpl(path: CStringRef) {
    var r = rmdir(path.ptr);
    if (r < 0) {
        throw GenericIOError(errno(), "rmdir");
    }
}




/// @section  PATH_SEPARATOR, PATH_LIST_SEPARATOR, rootDirectory?, absolutePath? 

private alias PATH_SEPARATOR = '/';
alias PATH_LIST_SEPARATOR = ':';

// TODO: implement on windows
rootDirectory?(s) = (s == "/");
absolutePath?(s) = beginsWith?(s, '/');



/// @section  slicedPath, splitPath, pathComponents 

slicedPath(path) {
    var path2 = directoryTailTrimmed(path);
    var p = reverseFind(path2, '/');
    var parent, child = slicedUpto(path2, p), slicedFrom(path2, p);
    return directoryTailTrimmed(parent), child;
}

pathDirname(path) = String(nthValue(#0, ..slicedPath(path)));
pathBasename(path) = String(nthValue(#1, ..slicedPath(path)));

splitPath(path) = ..mapValues(force, ..slicedPath(path));

private directoryTailTrimmed(path) {
    if (empty?(path))
        return slicedUpto(path, 0);
    var p = reverseFindIf(begin(path)+1, end(path), c => (c != '/'));
    return slicedUpto(path, p);
}

pathComponents(path) {
    var parts = Vector[String]();
    var parent, child = ..slicedPath(path);
    while (not empty?(child)) {
        push(parts, String(child));
        parent, child = ..slicedPath(parent);
    }
    if (not empty?(parent))
        push(parts, String(parent));
    reverseInPlace(parts);
    return move(parts);
}



/// @section  joinPath 

define joinPath;

[..S when allValues?(String?, ..S)]
overload joinPath(..parts:S) {
    var result = String();
    ..for (part in parts)
        appendPath(result, part);
    trimDirectoryTail(result);
    return move(result);
}

[A when String?(SequenceElementType(A))]
overload joinPath(parts:A) {
    var result = String();
    for (part in parts)
        appendPath(result, part);
    trimDirectoryTail(result);
    return move(result);
}

private appendPath(path:String, part) {
    if (absolutePath?(part)) {
        path = String(part);
    }
    else {
        if ((not empty?(path)) and (not endsWith?(path, '/')))
            push(path, '/');
        pushAll(path, part);
    }
}

private trimDirectoryTail(path:String) {
    if (endsWith?(path, '/') and (not rootDirectory?(path)))
        pop(path);
}



/// @section  pathExists? 

pathExistsImpl?(p: CStringRef) {
    var statBuf = unix.Struct_stat();
    var result = unix.lstat(p.ptr, @statBuf);
    return result == 0;
}

// these defines are not generated by clay-bindgen
// fortunately these are the same on most Unices
private alias S_IFDIR = 0x4000;
private alias S_IFREG = 0x8000;

pathIsDirectoryImpl?(p: CStringRef) {
    var statBuf = unix.Struct_stat();
    var result = unix.lstat(p.ptr, @statBuf);
    if (result != 0) {
        // TODO: throw if anything except ENOENT
        return false;
    }
    return (statBuf.st_mode & S_IFDIR) != 0;
}

pathIsRegularFileImpl?(p: CStringRef) {
    var statBuf = unix.Struct_stat();
    var result = unix.lstat(p.ptr, @statBuf);
    if (result != 0) {
        // TODO: throw if anything except ENOENT
        return false;
    }
    return (statBuf.st_mode & S_IFREG) != 0;
}



/// @section  systemPath, currentDirectory 

// TODO: implement on windows
systemPath() {
    var pathList = CStringRef(libc.getenv(cstring("PATH")));
    return split(pathList, PATH_LIST_SEPARATOR);
}

// TODO: implement on windows
currentDirectory() {
    var buf = String();
    resize(buf, 1024);

    while (true) {
        var result = unix.getcwd(Pointer[CChar](begin(buf)), size(buf));
        if (not null?(result))
            break;
        var err = unix.errno();
        if (err != unix.ERANGE)
            throw GenericIOError(err, "getcwd");
        resize(buf, 2*size(buf));
    }

    resize(buf, libc.strlen(Pointer[CChar](begin(buf))));
    return move(buf);
}



/// @section  pathToExecutable 

// TODO: implement on windows
define pathToExecutable;

overload pathToExecutable() = pathToExecutable(commandLine()[0]);

overload pathToExecutable(arg0) {
    var searchDirs = systemPath();
    insert(searchDirs, 0, currentDirectory());
    for (pathDir in searchDirs) {
        var p = joinPath(pathDir, arg0);
        if (pathExistsImpl?(CStringRef(p)))
            return move(p);
    }
    return String();
}

