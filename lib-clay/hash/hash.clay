
import vectors.generic.*;



//
// booleans, integers, floats, pointers, characters
//

inline overload hash(x:Bool) = SizeT(x);

[T | Integer?(T)]
inline overload hash(x:T) = SizeT(x);

[T | Float?(T)]
inline overload hash(x:T) = SizeT(wrapMultiply(PtrInt(x), 10000));

[T]
inline overload hash(x:Pointer[T]) = SizeT(x);

inline overload hash(x:Char) = SizeT(x);



//
// arrays
//

[T,n]
inline overload hash(a:Array[T,n]) = hashSequence(a);



//
// tuples
//

inline hashValues(..values) {
    var h = SizeT(0);
    ..for (x in values)
        h = wrapAdd(wrapMultiply(UInt64(7), h), wrapMultiply(UInt64(13), hash(x)));
    return h;
}
inline overload hashValues(value) = hash(value);

[..T]
inline overload hash(x:Tuple[..T]) = hashValues(..tupleElements(x));


//
// records
//

[T | Record?(T)]
inline overload hash(x:T) = hashValues(..recordFields(x));



//
// enumerations
//

[T | Enum?(T)]
inline overload hash(x:T) = SizeT(x);



//
// shared pointers
//

[T]
inline overload hash(x:SharedPointer[T]) = hash(x.ptr);



//
// strings
//

inline overload hash(a:String) = hashSequence(a);
inline overload hash(a:StringConstant) = hashSequence(a);



//
// vectors
//

[T]
inline overload hash(a:Vector[T]) = hashSequence(a);



//
// hashSequence
//

hashSequence(a) {
    var h = SizeT(0);
    var f = SizeT(11);
    for (x in a) {
        h = wrapAdd(h, wrapMultiply(f, hashValues(x)));
        f = wrapSubtract(wrapMultiply(UInt64(2), f), UInt64(1));
    }
    return h;
}



//
// variants
//

[T | Variant?(T)]
overload hash(x:T) = wrapAdd(wrapMultiply(23, variantTag(x)), hash(*x));



//
// reference types
//

[T | ReferenceType?(T)]
overload hash(x:T) = hash(referencePtr(x));


//
// statics
//

[x]
overload hash(s:Static[x]) = SizeT(0);
