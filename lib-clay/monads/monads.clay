import algorithms;
import lambdas.(Function);
import printer.(println);
import sequences;
import vectors.(Vector);

[FA when Functor?(FA)]
//(A->B, F[A]) : F[B]
overload fmap(f, functor : FA){
    alias A = typeInBox(FA);
    alias B = CallOutputTypes(f, A);
    return fmap(Function[[A], [B]](f), functor);
}

[MA when Monad?(MA)]
//(M[A], A -> M[B]) : M[B]
overload mbind(m : MA, f){
    alias A = typeInBox(MA);
    alias MB = CallOutputTypes(f, A);
    return mbind(m, Function[[A], [MB]](f));
}

[M when Monad?(M)]
overload mreturn(#M) {
    alias A = typeInBox(M);
    return mreturn(A(), #M);
}

[T]
pushAndReturn(forward xs : Vector[T], forward x : T){
    var y = xs;
    push(y, x);
    return move(y);
}

[M when Monad?(M)]
sequence(ms: Vector[M]){
    alias A = typeInBox(M);
    alias R = changeTypeInBox(#M, Vector[A]);
    var k = (m, m1) => old_mbind(xs => old_mbind(x => mreturn(pushAndReturn(xs, x),#R), m1), m);
    return algorithms.reduce(k, mreturn(Vector[A](), #R), ms);
}

[M when Monad?(M)]
sequence_(ms: Vector[M]){
    alias A = typeInBox(M);//Int32
    alias R = changeTypeInBox(#M, Vector[A]);
    return algorithms.reduce((>>), mreturn(#M), sequences.reverse(ms));
}

[A]
mapM(f, a: Vector[A]) = sequence(sequences.map(f, a));

[A]
mapM_(f, a: Vector[A]) = sequence_(sequences.map(f, a));

alias forM(a, f) = mapM(f, a);
alias forM_(a, f) = mapM(f, a);

[MM when Monad?(MM) and Monad?(typeInBox(MM))]
join(x : MM) : typeInBox(MM) = x >>= (x -> x);