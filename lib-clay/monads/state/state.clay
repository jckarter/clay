import lambdas.(Function);

record State[S, A](f: Function[[S], [Tuple[A,S]]]);

[S, A]
overload typeInBox(#State[S, A]) = A;

[S, A, B]
overload changeTypeInBox(#State[S, A], #B) = State[S, B];

[S, A]
overload Monad?(#State[S, A]) = true;

[S, A]
runState(state : State[S, A], st: S) = state.f(st);

[S, A]
evalState(state : State[S, A], st: S) = state.f(st).0;

[S, A]
execState(state : State[S, A], st: S) = state.f(st).1;


[S, A, B]
overload mreturn(x : B, #State[S,A]){
    return State[S, B](Function[[S], [Tuple[B,S]]](s => [x, s]));
}

[S, A]
overload mreturn(#State[S,A]) {
    return State[S,Int](Function[[S], [Tuple[Int,S]]](s => [0, s]));
}

[S, A]
overload mbind(g, p : State[S, A]) {
alias B = typeInBox(Type(g(A())));
return State(Function[[S], [Tuple[B, S]]](st => {var Z = runState(p, st);
                                                 var x, st_ = ..unpack(Z);
                                                 return runState(g(x), st_);}));
}

[OldS, S, A]
put(newState : S, #State[OldS,A]) 
{
var newState_ = newState;//FIXME: why this temp variable is needed?
return State[S,Int](Function[[S], [Tuple[Int,S]]]((oldState : S) => [0, newState_]));
}

[S, A]
get(#State[S, A]) = State(Function[[S], [Tuple[S,S]]](st => [st, st]));