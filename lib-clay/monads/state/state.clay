import lambdas.(Function);

record State[S, A](f: Function[[S], [Tuple[A,S]]]);

[S, A]
overload typeInBox(#State[S, A]) = A;

[S, A, B]
overload changeTypeInBox(#State[S, A], #B) = State[S, B];

[S, A]
overload Monad?(#State[S, A]) = true;

[S, A]
runState(state : State[S, A], st: S) = state.f(st);

[S, A]
evalState(state : State[S, A], st: S) = state.f(st).0;

[S, A]
execState(state : State[S, A], st: S) = state.f(st).1;

[S, A, B]
overload mreturn(x : B, #State[S,A]){
    return State[S, B](Function[[S], [Tuple[B,S]]](s => [x, s]));
}

[S, A, MB]
overload mbind(p : State[S, A], g : Function[[A], [MB]]) {
    alias B = typeInBox(MB);
    return State(Function[[S], [Tuple[B, S]]](st => {var x, st_ = ..unpack(runState(p, st));
                                                     return runState(g(x), st_);}));
}

[OldS, S, A]
put(newState : S, #State[OldS,A]) 
{
    var newState_ = newState;//FIXME: why this temp variable is needed?
    return State[S,Int](Function[[S], [Tuple[Int,S]]]((oldState : S) => [0, newState_]));
}

[S, A]
get(#State[S, A]) = State(Function[[S], [Tuple[S,S]]](st => [st, st]));