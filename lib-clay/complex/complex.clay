public import complex.core.*;
import numbers.floats.*;
import math.native.protocol.(abs);


overload floatBits(f:ILongDouble) = bitcast(Float80Bits, f);
overload floatBits(f:IDouble) = bitcast(UInt64, f);
overload floatBits(f:IFloat) = bitcast(UInt32, f);


define imagFromBits;
overload imagFromBits(m:UInt64,e:UInt64) = bitcast(ILongDouble, Float80Bits(m,e));
overload imagFromBits(b:UInt64) = bitcast(IDouble, b);
overload imagFromBits(b:UInt32) = bitcast(IFloat, b);

[I when Integer?(I)]
overload floatFromParts(#ILongDouble, neg?:Bool, exp:I, mant:UInt64)
    = imagFromBits(mant, bitor( UInt64(exp),
        if (neg?) 0x0000_0000_0000_8000_ul else 0_ul));

[I when Integer?(I)]
overload floatFromParts(#IDouble, neg?:Bool, exp:I, mant:UInt64)
    = imagFromBits(bitor(bitand(mant, mantissaMask(IDouble)),
        bitshl(bitand(UInt64(exp), exponentMask(IDouble)), mantissaSize(IDouble)),
        if (neg?) 0x8000_0000_0000_0000_ul else 0_ul));

[I when Integer?(I)]
overload floatFromParts(#IFloat ,neg?:Bool, exp:I, mant:UInt32)
    = imagFromBits(bitor(
        bitand(mant, mantissaMask(IFloat)),
        bitshl(bitand(UInt32(exp), exponentMask(IFloat)), mantissaSize(IFloat)),
        if (neg?) 0x8000_0000u else 0u ));

overload floatNegative?(f:ILongDouble) = bitand(floatBits(f).exponent, 0x8000u) != 0;
overload floatNegative?(f:IDouble) = bitand(floatBits(f), 0x8000_0000_0000_0000_ul) != 0;
overload floatNegative?(f:IFloat) = bitand(floatBits(f), 0x8000_0000u) != 0;


[T when Imaginary?(T)]
overload floatExponent(f:T) = bitand(bitshr(floatBits(f), mantissaSize(T)), exponentMask(T));
overload floatExponent(f:ILongDouble) = bitand(floatBits(f).exponent, 0x7FFFu);

overload floatMantissa(f:ILongDouble) = floatBits(f).mantissa;
overload floatMantissa(f:IDouble) = bitand(floatBits(f), mantissaMask(IDouble));
overload floatMantissa(f:IFloat) = bitand(floatBits(f), mantissaMask(IFloat));

overload infinity(#ILongDouble) = imagFromBits(0x8000_0000_0000_0000_ul,0x0000_0000_0000_7FFF_ul);
overload infinity(#IDouble) = imagFromBits(0x7FF0_0000_0000_0000_ul);
overload infinity(#IFloat) = imagFromBits(0x7F80_0000u);

overload negativeInfinity(#ILongDouble) = imagFromBits(0x8000_0000_0000_0000_ul,0x0000_0000_0000_FFFF_ul);
overload negativeInfinity(#IDouble) = imagFromBits(0xFFF0_0000_0000_0000_ul);
overload negativeInfinity(#IFloat) = imagFromBits(0xFF80_0000u);

overload nan(#ILongDouble) = imagFromBits(0xC000_0000_0000_0000_ul,0x0000_0000_0000_7FFF_ul);
overload nan(#IDouble) = imagFromBits(0x7FF8_0000_0000_0000_ul);
overload nan(#IFloat) = imagFromBits(0x7FC0_0000u);

overload snan(#ILongDouble) = imagFromBits(0x8000_0000_0000_0001_ul,0x0000_0000_0000_7FFF_ul);
overload snan(#IDouble) = imagFromBits(0x7FF0_0000_0000_0001_ul);
overload snan(#IFloat) = imagFromBits(0x7F80_0001u);

overload nan(#ILongDouble, sign?:Bool, payload:UInt64) = floatFromParts(ILongDouble,sign?, exponentMask(ILongDouble), payload);
overload nan(#IDouble, sign?:Bool, payload:UInt64) = floatFromParts(IDouble,sign?, exponentMask(IDouble), payload);
overload nan(#IFloat, sign?:Bool, payload:UInt32) = floatFromParts(IFloat,sign?, exponentMask(IFloat), payload);

overload qnanMask(#ILongDouble) = wrapBitshl(0x1ul,mantissaSize(ILongDouble)-1);
overload qnanMask(#IDouble) = wrapBitshl(0x1ul,mantissaSize(IDouble)-1);
overload qnanMask(#IFloat) = wrapBitshl(0x1u,mantissaSize(IFloat)-1);

overload snanMask(#ILongDouble) = bitshr(mantissaMask(ILongDouble),1);
overload snanMask(#IDouble) = bitshr(mantissaMask(IDouble),1);
overload snanMask(#IFloat) = bitshr(mantissaMask(IFloat),1);

[T when Imaginary?(T)]
overload nan(sign?:Bool, payload:T) = floatFromParts(T, sign?, exponentMask(T), bitor(floatMantissa(payload),qnanMask(T)));

[T when Imaginary?(T)]
overload snan(sign?:Bool, payload:T) = floatFromParts(T, sign?, exponentMask(T), bitand(floatMantissa(payload),snanMask(T)));

overload exponentBias(#ILongDouble) = 16383;
overload exponentBias(#IDouble) = 1023;
overload exponentBias(#IFloat) = 127;

overload mantissaSize(#ILongDouble) = 64;
overload mantissaSize(#IDouble) = 52;
overload mantissaSize(#IFloat) = 23;

overload mantissaMask(#ILongDouble) = 0xFFFF_FFFF_FFFF_FFFFul;
overload mantissaMask(#IDouble) = 0x000F_FFFF_FFFF_FFFFul;
overload mantissaMask(#IFloat) = 0x007F_FFFFu;

overload exponentSize(#ILongDouble) = 15;
overload exponentSize(#IDouble) = 11;
overload exponentSize(#IFloat) = 8;

overload exponentMask(#ILongDouble) = 0x7FFFul;
overload exponentMask(#IDouble) = 0x7FFul;
overload exponentMask(#IFloat) = 0xFFu;

overload signMask(#ILongDouble) = 0x8000ul;
overload signMask(#IDouble) = 0x8000_0000_0000_0000_ul;
overload signMask(#IFloat) = 0x8000_0000_ul;

overload floatMantissaZero(#ILongDouble) = 0x8000_0000_0000_0000_ul;
overload floatMantissaZero(#IDouble) = 0x0000_0000_0000_0000_ul;
overload floatMantissaZero(#IFloat) = 0x0000_0000_u;

overload signbit(x:ILongDouble) = Int(bitshr(floatBits(x).exponent,15));
overload signbit(x:IDouble) = Int(bitshr(floatBits(x),63));
overload signbit(x:IFloat) = Int(bitshr(floatBits(x),31));

overload floatBitsUnsigned(x:ILongDouble) {
    var tmp = floatBits(x);
    tmp.exponent = bitand(tmp.exponent,0x7FFFu);
    return tmp;
}
overload floatBitsUnsigned(x:IDouble) = bitand(floatBits(x),0x7FFF_FFFF_FFFF_FFFFul);
overload floatBitsUnsigned(x:IFloat) = bitand(floatBits(x),0x7FFF_FFFFu);

[T when Imaginary?(T)] overload finite?(x:T) = floatExponent(x) != exponentMask(T);
[T when Imaginary?(T)] overload infinity?(x:T) = floatExponent(x) == exponentMask(T) and floatMantissa(x)==0;
[T when Imaginary?(T)] overload positiveInfinity?(x:T) = x == infinity(T);
[T when Imaginary?(T)] overload negativeInfinity?(x:T) = x == negativeInfinity(T);
[T when Imaginary?(T)] overload nan?(x:T) = floatExponent(x) == exponentMask(T) and floatMantissa(x)!=0;
[T when Imaginary?(T)] qnan?(x:T) {
    var m = floatMantissa(x);
    return floatExponent(x) == exponentMask(T) and m!=0 and bitshr(m,mantissaSize(T)-1)==1;
}
[T when Imaginary?(T)] snan?(x:T) {
    var m = floatMantissa(x);
    return floatExponent(x) == exponentMask(T) and m!=0 and bitshr(m,mantissaSize(T)-1)==0;
}
[T when Imaginary?(T)] overload subnormal?(x:T) = floatExponent(x)==T(0) and x!=T(0);
[T when Imaginary?(T)] overload normalized?(x:T) = not subnormal?(x) and finite?(x);




/// @section  (==), (!=), less?, lessEquals?, (>), (>=) 

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (==)(z:C, y:T) = imag(z) != T(0) and (==)(real(z),y);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (==)(y:T, z:C) = (==)(z,y);

[T when Complex?(T)]
forceinline overload (==)(z:T, y:T) = (==)(real(z),real(y)) and (==)(imag(z),imag(y));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (!=)(z:C, y:T) = not (==)(z, y);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (!=)(y:T,z:C) = not (==)(z, y);

[T when Complex?(T)]
forceinline overload (!=)(z:T, y:T) = not (==)(z,y);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (<)(a:C, b:T) = (<)(real(a), b);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (<)(a:T, b:C) = (<)(a, real(b));

[C when Complex?(C)]
forceinline overload (<)(a:C, b:C) = (<)(real(a), real(b));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (<=)(a:C, b:T) = (<=)(real(a), b);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (<=)(a:T, b:C) = (<=)(a, real(b));

[C when Complex?(C)]
forceinline overload (<=)(a:C, b:C) = (<=)(real(a), real(b));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (>)(a:C, b:T) = (>)(real(a), b);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (>)(a:T, b:C) = (>)(a, real(b));

[C when Complex?(C)]
forceinline overload (>)(a:C, b:C) = (>)(real(a), real(b));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (>=)(a:C, b:T) = (>=)(real(a), b);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload (>=)(a:T, b:C) = (>=)(a, real(b));

[C when Complex?(C)]
forceinline overload (>=)(a:C, b:C) = (>=)(real(a), real(b));

[T when Complex?(T)]
overload zero?(z:T) = real(z) == 0. and imag(z) == 0.j;

/// @section  unary ops 

[T when Complex?(T)]
forceinline overload (-)(z:T) = Complex(-real(z),-imag(z));

[T when Complex?(T)]
forceinline overload (+)(z:T) = z;

[T when Complex?(T)]
define conj(z:T);

forceinline overload conj(z) = Complex(real(z),-imag(z));

[T when Imaginary?(T)]
forceinline overload conj(z:T) = -z;

[C when Complex?(C)]
forceinline rect(c:C) = real(c), imag(c);

[C when Complex?(C)]
forceinline rectValues(c:C) = real(c), imagValue(c);

/// @section  binary ops 

// complex/complex

[T,U when Complex?(T,U)]
forceinline overload (+)(z:T, y:U) = Complex(real(z)+real(y), imag(z)+imag(y));

[T,U when Complex?(T,U)]
forceinline overload (-)(z:T, y:U) = Complex(real(z)-real(y), imag(z)-imag(y));

[T,U when Complex?(T,U)]
forceinline overload (*)(z:T, y:U) {
    alias iy = imagValue(y);
    alias ry = real(y);
    alias iz = imagValue(z);
    alias rz = real(z);
    var ac, bd = rz * ry, iz * iy;
    return Complex(ac-bd, (rz+iz) * (ry+iy) + (-ac-bd));
}

[T,U when Complex?(T,U)]
forceinline overload (/)(z:T, y:U) {
    alias iy = imagValue(y);
    alias ry = real(y);
    alias iz = imagValue(z);
    alias rz = real(z);
    if(abs(ry) < abs(iy)){
        var rat = ry / iy;
        var den = 1./(rat*ry+iy);
        return Complex((rat*rz+iz) * den, (rat*iz-rz) * den);
    }else{
        var rat = iy / ry;
        var den = 1./(rat*iy+ry);
        return Complex((rat*iz+rz) * den, (-rat*rz+iz) * den);
    }
}


// Float/imaginary -> complex

[T,C when Imaginary?(T) and Float?(C)]
forceinline overload (+)(a:C, z:T) = Complex(a,z);

[T,C when Imaginary?(T) and Float?(C)]
forceinline overload (+)(a:T, z:C) = Complex(z,a);

[T,C when Imaginary?(T) and Float?(C)]
forceinline overload (-)(a:T, z:C) = Complex(-z,a);

[T,C when Imaginary?(T) and Float?(C)]
forceinline overload (-)(a:C, z:T) = Complex(a,-z);


// Float/complex -> complex

[T,C when Float?(T) and Complex?(C)]
forceinline overload (+)(a:T, z:C) = Complex(a + real(z),imag(z));

[T,C when Float?(T) and Complex?(C)]
forceinline overload (+)(z:C, a:T) = (+)(a,z);

[T,C when Float?(T) and Complex?(C)]
forceinline overload (-)(z:C, y:T) = Complex(real(z)-y,imag(z));

[T,C when Float?(T) and Complex?(C)]
forceinline overload (-)(y:T,z:C) = Complex(y + real(z), -imag(z));

[T,C when Float?(T) and Complex?(C)]
forceinline overload (*)(z:C, y:T) = Complex(real(z)*y,imag(z)*y);

[T,C when Float?(T) and Complex?(C)]
forceinline overload (*)(y:T,z:C) = (*)(z,y);

[T,C when Float?(T) and Complex?(C)]
forceinline overload (/)(z:C, y:T) {
    var d = T(1)/y;
    return Complex(real(z)*d,imag(z)*d);
}

[T,C when Float?(T) and Complex?(C)]
forceinline overload (/)(y:T,z:C) = (/)(Complex(y,T(0)),z);

// Imaginary/complex -> complex

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (+)(a:T, z:C) = Complex(real(z), imag(z) + a);

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (+)(z:C, a:T) = (+)(a,z);

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (-)(z:C, y:T) = Complex(real(z), imag(z) - y);

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (-)(y:T,z:C) = Complex(-real(z), y - imag(z));

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (*)(z:C, y:T) = Complex(imag(z)*y, real(z)*y);

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (*)(y:T,z:C) = (*)(z,y);

[T,C when Imaginary?(T) and Complex?(C)]
forceinline overload (/)(z:C, y:T) = Complex(imag(z)/y, -real(z)/y);

//XXX THESE NEED ATTENTION
[T when Complex?(T)]
forceinline overload max(x:T,y:T) = max(abs(x),abs(y));

[C when Complex?(C)]
forceinline overload min(x:C,y:C) = min(abs(x),abs(y));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload max(x:T,y:C) = max(x,abs(y));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload max(x:C,y:T) = max(abs(x),y);

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload min(x:T,y:C) = min(x,abs(y));

[T,C when Numeric?(T) and Complex?(C)]
forceinline overload min(x:C,y:T) = min(abs(x),y);

[T when Complex?(T)]
forceinline overload nan?(x:T) = nan?(real(x)) or nan?(imag(x));

[T when Complex?(T)]
forceinline overload finite?(x:T) = floatExponent(abs(x)) != exponentMask((ComplexRealType(T)));

[T when Complex?(T)]
forceinline overload infinity?(x:T) = abs(x) == infinity(ComplexBaseType(T));

[T when Complex?(T)]
forceinline overload negativeInfinity?(x:T) = negativeInfinity?(real(x));

[T when Complex?(T)]
forceinline overload subnormal?(x:T) = subnormal?(real(x)) or subnormal?(imag(x));

[T when Complex?(T)]
forceinline overload normalized?(x:T) = not subnormal?(x) and finite?(x);

[T when Complex?(T)]
overload infinity(#T) = Complex(infinity(ComplexRealType(T)),infinity(ComplexImagType(T)));

[T when Complex?(T)]
overload negativeInfinity(#T) = Complex(negativeInfinity(ComplexRealType(T)),negativeInfinity(ComplexImagType(T)));

[T when Complex?(T)]
overload nan(#T) = Complex(nan(ComplexRealType(T)),nan(ComplexImagType(T)));

[T when Complex?(T)]
overload snan(#T) = Complex(snan(ComplexRealType(T)),snan(ComplexImagType(T)));

[T when Float?(T)]
forceinline fromPolar(m:T,ph:T) = Complex(m*sin(ph),m*cos(ph));
