public import complex.types.*;
public import complex.platform.*;
import core.numbers.(private BiggerFloat?, private BiggerNumeric?);

alias ComplexFloat = Complex32;
alias ComplexDouble = Complex64;
alias ComplexLongDouble = Complex80;

alias CComplexFloat = ComplexFloat;
alias CComplexDouble = ComplexDouble;

alias IFloat = Imag32;
alias IDouble = Imag64;
alias ILongDouble = Imag80;


forceinline overload LeastPositive(#Imag32) : Imag32
    = numericConvert(Imag32,LeastPositive(Float32));
forceinline overload LeastPositiveNormalized(#Imag32) : Imag32
    = numericConvert(Imag32,LeastPositiveNormalized(Float32));
forceinline overload GreatestPositiveFinite(#Imag32) : Imag32
    = numericConvert(Imag32,GreatestPositiveFinite(Float32));

forceinline overload LeastPositive(#Imag64) : Imag64
    = numericConvert(Imag64,LeastPositive(Float64));
forceinline overload LeastPositiveNormalized(#Imag64) : Imag64
    = numericConvert(Imag64,LeastPositiveNormalized(Float64));
forceinline overload GreatestPositiveFinite(#Imag64) : Imag64
    = numericConvert(Imag64,GreatestPositiveFinite(Float64));

forceinline overload LeastPositive(#Imag80) : Imag80
    = numericConvert(Imag80,LeastPositive(Float80));
forceinline overload LeastPositiveNormalized(#Imag80) : Imag80
    = numericConvert(Imag80,LeastPositiveNormalized(Float80));
forceinline overload GreatestPositiveFinite(#Imag80) : Imag80
    = numericConvert(Imag80,GreatestPositiveFinite(Float80));


overload PrimitiveType?(#Imag32) : Bool = true;
overload PrimitiveType?(#Imag64) : Bool = true;
overload PrimitiveType?(#Imag80) : Bool = true;
overload PrimitiveType?(#Complex32) : Bool = true;
overload PrimitiveType?(#Complex64) : Bool = true;
overload PrimitiveType?(#Complex80) : Bool = true;


define Imaginary?(..T) : Bool;
overload Imaginary?(T) : Bool = false;
overload Imaginary?(#Imag32) : Bool = true;
overload Imaginary?(#Imag64) : Bool = true;
overload Imaginary?(#Imag80) : Bool = true;
[A, B] overload Imaginary?(#A, #B) : Bool = Imaginary?(A) and Imaginary?(B);


/// builtin imaginary types
BuiltinImaginaryTypes() = Imag32, Imag64, Imag80;

overload Numeric?(#Imag32) : Bool = true;
overload Numeric?(#Imag64) : Bool = true;
overload Numeric?(#Imag80) : Bool = true;

[A,B when Imaginary?(A,B)]
overload BiggerFloat?(#A, #B) : Bool  = TypeSize(A) > TypeSize(B);

[A,B when (Float?(A) and Imaginary?(B)) or (Float?(B) and Imaginary?(A))]
overload BiggerFloat?(#A, #B) : Bool  = TypeSize(A) > TypeSize(B);

[A,B when Imaginary?(A) and Integer?(B)]
overload BiggerNumeric?(#A, #B) : Bool  = true;

[A,B when Integer?(A) and Imaginary?(B)]
overload BiggerNumeric?(#A, #B) : Bool = false;

[A,B when Imaginary?(A,B)]
overload BiggerNumeric?(#A, #B) : Bool = BiggerFloat?(A,B);

[A,B when (Float?(A) and Imaginary?(B)) or (Float?(B) and Imaginary?(A))]
overload BiggerNumeric?(#A, #B) : Bool = BiggerFloat?(A,B);


define ImagBaseType;
overload ImagBaseType(#Imag32) = Float;
overload ImagBaseType(#Imag64) = Double;
overload ImagBaseType(#Imag80) = LongDouble;


[T,I when Float?(T) and Imaginary?(I)]
forceinline overload T(a:I) : T = T(0.);

[T,I when Float?(T) and Imaginary?(I)]
forceinline overload I(a:T) : I = I(0.j);



[A when Imaginary?(A)]
forceinline overload (==)(a:A, b:A) : Bool  = floatOrderedEquals?(a, b);

[A when Imaginary?(A)]
forceinline overload (!=)(a:A, b:A) : Bool = floatUnorderedNotEquals?(a, b);

[A when Imaginary?(A)]
forceinline overload (<)(a:A, b:A) : Bool = floatOrderedLesser?(a, b);

[A when Imaginary?(A)]
forceinline overload (<=)(a:A, b:A) : Bool = floatOrderedLesserEquals?(a, b);

[A when Imaginary?(A)]
forceinline overload (>)(a:A, b:A) : Bool = floatOrderedGreater?(a, b);

[A when Imaginary?(A)]
forceinline overload (>=)(a:A, b:A) : Bool = floatOrderedGreaterEquals?(a, b);


/// @section  Imaginary binary ops 


[A,B when Numeric?(A) and Imaginary?(B)]
forceinline overload (*)(a:A, b:B) = numericMultiply(numericConvert(B,a), b);

[A,B when Numeric?(B) and Imaginary?(A)]
forceinline overload (*)(a:A, b:B) = numericMultiply(a, numericConvert(A,b));

[A when Imaginary?(A)]
forceinline overload (*)(a:A, b:A) = numericConvert(ImagBaseType(A),(-)(numericMultiply(a, b)));

[A,B when Numeric?(A) and Imaginary?(B)]
forceinline overload (/)(a:A, b:B) = (/)(numericConvert(B,-a), b);

[A,B when Numeric?(B) and Imaginary?(A)]
forceinline overload (/)(a:A, b:B) = (/)(a, numericConvert(A,b));

[A when Imaginary?(A)]
forceinline overload (/)(a:A, b:A) = numericConvert(ImagBaseType(A),floatDivide(a, b));


define Complex?;

overload Complex?(T) = false;
overload Complex?(#Complex32) = true;
overload Complex?(#Complex64) = true;
overload Complex?(#Complex80) = true;
[A, B] overload Complex?(#A, #B) = Complex?(A) and Complex?(B);

private define re;
private define im;

forceinline overload re(z:Complex32) = Pointer[Float](@z);
forceinline overload re(z:Complex64) = Pointer[Double](@z);
forceinline overload re(z:Complex80) = Pointer[LongDouble](@z);

forceinline overload im(z:Complex32) = (Pointer[IFloat](@z)+1);
forceinline overload im(z:Complex64) = (Pointer[IDouble](@z)+1);
forceinline overload im(z:Complex80) = (Pointer[ILongDouble](@z)+1);

[C when Complex?(C)]
forceinline real(z:C) = re(z)^;


define imag;
define imagValue;

[C when Complex?(C)]
forceinline overload imag(z:C) = im(z)^;
[C when Complex?(C)]
forceinline overload imagValue(z:C) = numericConvert(ComplexBaseType(C),im(z)^);

[I when Imaginary?(I)]
forceinline overload imag(z:I) = z;
forceinline overload imagValue(z:Imag32) = numericConvert(Float32, z);
forceinline overload imagValue(z:Imag64) = numericConvert(Float64, z);
forceinline overload imagValue(z:Imag80) = numericConvert(Float80, z);

define Complex;
forceinline overload Complex(a:Float,b:IFloat) --> r:Complex32 { re(r)^ = a; im(r)^ = b;}
forceinline overload Complex(a:Double,b:IDouble) --> r:Complex64 { re(r)^ = a; im(r)^ = b;}
forceinline overload Complex(a:LongDouble,b:ILongDouble) --> r:Complex80 { re(r)^ = a; im(r)^ = b;}
forceinline overload Complex(a:Float,b:IDouble) --> r:Complex64 { re(r)^ = Double(a); im(r)^ = b;}
forceinline overload Complex(a:Float,b:ILongDouble) --> r:Complex80 { re(r)^ = LongDouble(a); im(r)^ = b;}
forceinline overload Complex(a:Double,b:IFloat) --> r:Complex64 { re(r)^ = a; im(r)^ = numericConvert(IDouble,b);}
forceinline overload Complex(a:Double,b:ILongDouble) --> r:Complex80 { re(r)^ = LongDouble(a); im(r)^ = b;}
forceinline overload Complex(a:LongDouble,b:IFloat) --> r:Complex80 { re(r)^ = a; im(r)^ = numericConvert(ILongDouble,b);}
forceinline overload Complex(a:LongDouble,b:IDouble) --> r:Complex80 { re(r)^ = a; im(r)^ = numericConvert(ILongDouble,b);}
forceinline overload Complex(a:Float,b:Float) = Complex(a, numericConvert(IFloat,b));
forceinline overload Complex(a:Double,b:Double) = Complex(a, numericConvert(IDouble,b));
forceinline overload Complex(a:LongDouble,b:LongDouble) = Complex(a, numericConvert(ILongDouble,b));
forceinline overload Complex(a:Float,b:Double) = Complex(Double(a), numericConvert(IDouble,b));
forceinline overload Complex(a:Float,b:LongDouble) = Complex(LongDouble(a), numericConvert(ILongDouble,b));
forceinline overload Complex(a:Double,b:Float) = Complex(a, numericConvert(IDouble,b));
forceinline overload Complex(a:Double,b:LongDouble) = Complex(LongDouble(a), numericConvert(ILongDouble,b));
forceinline overload Complex(a:LongDouble,b:Float) = Complex(a, numericConvert(ILongDouble,b));
forceinline overload Complex(a:LongDouble,b:Double) = Complex(a, numericConvert(ILongDouble,b));

[T when Float?(T)]
forceinline overload Complex(a:T) = Complex(a,0.f);

[T when Imaginary?(T)]
forceinline overload Complex(a:T) = Complex(0.f,a);

[C when Complex?(C)]
define ComplexBaseType(#C);
overload ComplexBaseType(#Complex32) = Float;
overload ComplexBaseType(#Complex64) = Double;
overload ComplexBaseType(#Complex80) = LongDouble;

[C when Complex?(C)]
define ComplexImagType(#C);
overload ComplexImagType(#Complex32) = IFloat;
overload ComplexImagType(#Complex64) = IDouble;
overload ComplexImagType(#Complex80) = ILongDouble;

define ComplexRealType;

[T when Complex?(T)]
overload ComplexRealType(#T) = ComplexBaseType(T);

[T when Complex?(T)]
overload ComplexRealType(z:T) = Type(real(z));

[T when Complex?(T)]
overload ComplexImagType(z:T) = Type(imag(z));

define ComplexType;

[T when Complex?(T)]
overload ComplexType(#T) = T;

[T when Float?(T)]
overload ComplexType(#T) = Type(Complex(T()));

[T when Complex?(T)]
overload T() = T(0.);

[C,T when Complex?(C,T) and C != T]
forceinline overload C(a:T) = Complex(ComplexBaseType(C)(real(a)), ComplexBaseType(C)(imag(a)));

[T,C when (Float?(T) or Imaginary?(T)) and Complex?(C)]
forceinline overload C(a:T) = Complex(ComplexBaseType(C)(a));

[U,T,C when Float?(U) and Float?(T) and Complex?(C)]
forceinline overload C(a:U, b:T) = Complex(ComplexBaseType(C)(a), ComplexBaseType(C)(b));
[U,T,C when Float?(U) and Imaginary?(T) and Complex?(C)]
forceinline overload C(a:U, b:T) = Complex(ComplexBaseType(C)(a), ComplexImagType(C)(b));

[I,C when Integer?(I) and Complex?(C)]
forceinline overload C(a:I) = Complex(ComplexBaseType(C)(a));


