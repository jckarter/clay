

/// @section  Range 

record Range[T] (
    begin:T,
    end:T,
);

[T]
LightweightSequence?(#Range[T]) : Bool = true;

[T]
forceinline size(a:Range[T]) : SizeT 
    = if (a.end < a.begin) SizeT(0) else SizeT(a.end - a.begin);

[T,I when Integer?(I)]
forceinline index(a:Range[T], i:I) : T = T(a.begin + i);

[T]
forceinline iterator(a:Range[T]) : Range[T] = a;

[T]
forceinline reverseIterator(a:Range[T]) : ReverseRange[T] 
    = ReverseRange(a.end, a.begin);

[T]
forceinline nextValue(a:Range[T]) : Maybe[T] {
    if (a.begin < a.end) {
        var temp = Maybe(a.begin);
        inc(a.begin);
        return move(temp);
    } else {
        return nothing(T);
    }
}

[T]
forceinline begin(a:Range[T]) : ValueCoordinate[T] 
    = ValueCoordinate(a.begin);

[T]
forceinline end(a:Range[T]) : ValueCoordinate[T] 
    = ValueCoordinate(a.end);



/// @section  ReverseRange 

record ReverseRange[T] (
    end : T,
    begin : T,
);

[T]
LightweightSequence?(#ReverseRange[T]) : Bool = true;

[T]
forceinline size(a:ReverseRange[T]) : SizeT 
    = if (a.end < a.begin) SizeT(0) else SizeT(a.end - a.begin);

[T,I when Integer?(I)]
forceinline index(a:ReverseRange[T], i:I) : T = T(a.end - i - 1);

[T]
forceinline iterator(a:ReverseRange[T]) : ReverseRange[T] = a;

[T]
forceinline reverseIterator(a:ReverseRange[T]) : Range[T] 
    = Range(a.begin, a.end);

[T]
forceinline nextValue(a:ReverseRange[T]) : Maybe[T] {
    if (a.begin < a.end) {
        dec(a.end);
        return Maybe(a.end);
    } else {
        return nothing(T);
    }
}

[T]
forceinline begin(a:ReverseRange[T]) : ValueReverseCoordinate[T] 
    = ValueReverseCoordinate(a.end);

[T]
forceinline end(a:ReverseRange[T]) : ValueReverseCoordinate[T]
    = ValueReverseCoordinate(a.begin);



/// @section  range, reverseRange 

define range;

[T]
forceinline range(begin:T, end:T) : Range[T] = Range(begin, end);

[A,B when Integer?(A) and Integer?(B)]
forceinline range(begin:A, end:B) =
    Range(toBiggerNumericType(A, B, begin),
          toBiggerNumericType(A, B, end));

[I when Integer?(I)]
forceinline range(begin:I, end:I) : Range[I] = Range(begin, end);

[I when Integer?(I)]
forceinline range(end:I) : Range[I] = Range(I(0), end);


define reverseRange;

[T]
forceinline reverseRange(end:T, begin:T) : ReverseRange[T] 
    = ReverseRange(end, begin);

[A,B when Integer?(A) and Integer?(B)]
forceinline reverseRange(end:A, begin:B) =
    ReverseRange(toBiggerNumericType(A, B, end),
                 toBiggerNumericType(A, B, begin));

[I when Integer?(I)]
forceinline reverseRange(end:I, begin:I) : ReverseRange[I]
    = ReverseRange(end, begin);

[I when Integer?(I)]
forceinline reverseRange(end:I) : ReverseRange[I]
    = ReverseRange(end, I(0));



/// @section  CoordinateRange 

record CoordinateRange[T] (
    begin : T,
    end : T,
);

[T when ContiguousCoordinate?(T)]
ContiguousSequence?(#CoordinateRange[T]) : Bool = true;

[T]
LightweightSequence?(#CoordinateRange[T]) : Bool = true;

[T]
forceinline size(a:CoordinateRange[T]) = SizeT(a.end - a.begin);

[T,I when Integer?(I)]
forceinline index(a:CoordinateRange[T], i:I) {
    assert["boundsChecks"](i >= 0 and i < size(a),
        CoordinateRange[T], " index out of bounds");
    return forward ..(a.begin + i)^;
}

[T]
forceinline iterator(a:CoordinateRange[T]) : CoordinateRange[T] = a;

[T]
forceinline reverseIterator(a:CoordinateRange[T]) : ReverseCoordinateRange[T]
    = ReverseCoordinateRange(a.end, a.begin);

[T]
forceinline nextValue(a:CoordinateRange[T]) : T {
    if (a.begin < a.end) {
        var p = a.begin;
        inc(a.begin);
        return move(p);
    } else
        return T();
}

[T]
forceinline begin(a:CoordinateRange[T]) : T = a.begin;

[T]
forceinline end(a:CoordinateRange[T]) : T = a.end;


/// @section  ReverseCoordinateRange 

record ReverseCoordinateRange[T] (
    end : T,
    begin : T,
);

[T]
LightweightSequence?(#ReverseCoordinateRange[T]) : Bool = true;

[T]
forceinline size(a:ReverseCoordinateRange[T]) = SizeT(a.end - a.begin);

[T,I when Integer?(I)]
forceinline index(a:ReverseCoordinateRange[T], i:I) {
    assert["boundsChecks"](i >= 0 and i < size(a),
        ReverseCoordinateRange[T], " index out of bounds");
    return forward ..(a.end - i - 1)^;
}

[T]
forceinline iterator(a:ReverseCoordinateRange[T]) : ReverseCoordinateRange[T] = a;

[T]
forceinline reverseIterator(a:ReverseCoordinateRange[T]) : CoordinateRange[T]
    = CoordinateRange(a.begin, a.end);

// FIXME multiple-value and rvalue coordinates
[T]
forceinline nextValue(a:ReverseCoordinateRange[T]) : T {
    if (a.begin < a.end) {
        dec(a.end);
        return a.end;
    } else
        return T();
}

[T]
forceinline begin(a:ReverseCoordinateRange[T]) : ReverseCoordinate[T]
    = ReverseCoordinate(a.end);

[T]
forceinline end(a:ReverseCoordinateRange[T]) : ReverseCoordinate[T] 
    = ReverseCoordinate(a.begin);



/// @section  coordinateRange, reverseCoordinateRange 

[T]
forceinline coordinateRange(begin:T, end:T) : CoordinateRange[T]
    = CoordinateRange(begin, end);
[T]
forceinline reverseCoordinateRange(end:T, begin:T) : ReverseCoordinateRange[T]
    = ReverseCoordinateRange(end, begin);
