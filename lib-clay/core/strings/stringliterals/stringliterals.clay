
/// @section  StringLiteralRef 

record StringLiteralRef (
    sizep : Pointer[SizeT],
);


/// @section  predicates 

ContiguousSequence?(#StringLiteralRef) : Bool = true;
[s when StringLiteral?(s)]
ContiguousSequence?(#Static[s]) : Bool = true;



/// @section  constructors 

[s when StringLiteral?(s)]
forceinline StringLiteralRef(#s) = StringLiteralRef(stringTableConstant(s));
forceinline StringLiteralRef() = StringLiteralRef(stringTableConstant(""));


/// @section  size, begin, end, index 

forceinline size(a:StringLiteralRef) = a.sizep^;

forceinline begin(a:StringLiteralRef) : Pointer[Char] = Pointer[Char](a.sizep + 1);
forceinline end(a:StringLiteralRef) = begin(a) + size(a);

[I when Integer?(I)]
forceinline index(a:StringLiteralRef, i:I) : ByRef[Char] {
    assert["boundsChecks"](i >= 0 and i < size(a), "StringLiteralRef index out of bounds");
    return ref (begin(a) + i)^;
}

[s when StringLiteral?(s)]
forceinline size(#s) = stringLiteralByteSize(s);
[s when StringLiteral?(s)]
forceinline begin(#s) : Pointer[Char] = Pointer[Char](stringTableConstant(s) + 1);
[s when StringLiteral?(s)]
forceinline end(#s) = begin(s) + size(s);

[s, I when StringLiteral?(s) and Integer?(I)]
forceinline index(#s, i:I) : ByRef[Char] {
    assert["boundsChecks"](i >= 0 and i < size(s), "literal \"", s, "\" index out of bounds");
    return ref (begin(s) + i)^;
}

[s, n when StringLiteral?(s) and n >= 0 and n < size(s)]
forceinline staticIndex(#s, #n) : Char 
    = Char(stringLiteralByteIndex(#s,#n));



/// @section  cstring 

define cstring(a) : Pointer[Int8];

forceinline cstring(a:StringLiteralRef) : Pointer[Int8]
    = Pointer[Int8](begin(a));

[s when StringLiteral?(s)]
forceinline cstring(#s) : Pointer[Int8] = Pointer[Int8](begin(s));


/// @section  coordinates and iteration 

forceinline iterator(a:StringLiteralRef) = coordinateRange(begin(a), end(a));
[s when StringLiteral?(s)]
forceinline iterator(#s) = coordinateRange(begin(s), end(s));

forceinline reverseIterator(a:StringLiteralRef) =
    reverseCoordinateRange(end(a), begin(a));
[s when StringLiteral?(s)]
forceinline reverseIterator(#s) =
    reverseCoordinateRange(end(a), begin(a));


/// @section  string literal concatenation 

private define StringLiteralStatic?(s) : Bool;
StringLiteralStatic?(s) : Bool = false;
[s]
StringLiteralStatic?(#Static[s]) : Bool = StringLiteral?(s);

StringLiteralType?(..SS) : Bool = allValues?(S -> StringLiteralStatic?(S), ..SS);

[..SS when StringLiteralType?(..SS)]
forceinline (++)(..ss:SS) = stringLiteralConcat(..ss);


/// @section  string literal manipulation 

// stringLiteralStartsWith?

define stringLiteralStartsWith?(..a) : Bool;

stringLiteralStartsWith?(a, b) : Bool = false;

[identifier, startsWith when size(identifier) >= size(startsWith)]
stringLiteralStartsWith?(#identifier, #startsWith)
      = stringLiteralByteSlice(identifier, #0, #size(startsWith))
        == startsWith;

// stringLiteralEndsWith?

define stringLiteralEndsWith?;

stringLiteralEndsWith?(a, b) : Bool = false;

[identifier, endsWith when size(identifier) >= size(endsWith)]
stringLiteralEndsWith?(#identifier, #endsWith) : Bool
    = stringLiteralByteSlice(identifier,
          #(size(identifier) - size(endsWith)),
          #size(identifier)
      ) == endsWith;

// stringLiteralFind

define stringLiteralFind;

[identifier, sub, start when
    StringLiteral?(identifier) and StringLiteral?(sub)
]
stringLiteralFind(#identifier, #sub, #start)
    = stringLiteralFind(identifier, sub, #(start + 1));

[identifier, sub, start when
    StringLiteral?(identifier) and StringLiteral?(sub)
    and size(identifier) < size(sub) + start
]
stringLiteralFind(#identifier, #sub, #start) = -1;

[identifier, sub, start when
    StringLiteral?(identifier) and StringLiteral?(sub)
    and size(identifier) >= size(sub) + start
    and stringLiteralByteSlice(identifier, #start, #(start + size(sub)))
        == sub
]
stringLiteralFind(#identifier, #sub, #start) = start;

stringLiteralFind(identifier, sub) = stringLiteralFind(identifier, sub, #0);

// strl

define strl;

strl(..xx) = stringLiteralConcat(..mapValues(strl, ..xx));

[x]
strl(#x) = StaticName(#x);
[i when StringLiteral?(i)]
strl(#i) = i;

strl() = "";

// stringLiteralCapitalize, stringLiteralDecapitalize

define stringLiteralCapitalize;
define stringLiteralDecapitalize;

stringLiteralCapitalize("") = "";
[s when StringLiteral?(s) and size(s) >= 1]
stringLiteralCapitalize(#s)
    = stringLiteralConcat(stringLiteralFromBytes(#(Int(asciiUpper(s.0)))), stringLiteralByteSlice(s, #1, #size(s)));

stringLiteralDecapitalize("") = "";
[s when StringLiteral?(s) and size(s) >= 1]
stringLiteralDecapitalize(#s)
    = stringLiteralConcat(stringLiteralFromBytes(#(Int(asciiLower(s.0)))), stringLiteralByteSlice(s, #1, #size(s)));

// stringLiteralChars, stringLiteralStaticChars, stringLiteralFromChars
// XXX utf8

[s when StringLiteral?(s)]
stringLiteralChars(#s) = ..mapValues(Char, ..stringLiteralBytes(s));

[s when StringLiteral?(s)]
stringLiteralStaticChars(#s) =
    ..mapValues(n -> #Char(stringLiteralByteIndex(s, n)), ..staticIntegers(#size(s)));

[c]
private staticCharToByte(#c) = #Int(c);

stringLiteralFromChars(..c) = stringLiteralFromBytes(..mapValues(staticCharToByte, ..c));
