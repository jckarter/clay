


/// @section  eachValue, mapValues, foldValues, weaveValues, reverseValues

forceinline eachValue(fn, ..xs) {
    ..for (x in xs) {
        fn(x);
    }
}

define mapValues private overload;
forceinline mapValues(fn, forward x, forward ..xs)
    = forward ..fn(x), ..mapValues(fn, ..xs);
forceinline mapValues(fn) = ;

private define _mapIndexedValues;
[n] forceinline _mapIndexedValues(fn, #n, forward x, forward ..xs)
    = forward ..fn(x, n), .._mapIndexedValues(fn, #n+1, ..xs);
[n] forceinline _mapIndexedValues(fn, #n) = ;

mapIndexedValues(fn, forward ..values) = forward .._mapIndexedValues(fn, #0, ..values);

// filter values using given predicate
// unlike most other functions, all parameters must be static values
[Fn]
define filterValues(#Fn, ..xs) private overload;
[Fn, First when Fn(First)]
filterValues(#Fn, #First, ..xs) = #First, ..filterValues(#Fn, ..xs);
[Fn, First when not Fn(First)]
filterValues(#Fn, #First, ..xs) = ..filterValues(#Fn, ..xs);
[Fn]
filterValues(#Fn) = ;

define foldValues private overload;
forceinline foldValues(fn, forward x, forward ..xs)
    = fn(x, foldValues(fn, ..xs));
forceinline foldValues(fn, forward x) = forward x;

define foldlValues private overload;
forceinline foldlValues(fn, forward x1, forward x2, forward ..xs)
    = foldlValues(fn, fn(x1, x2), ..xs);
forceinline foldlValues(fn, forward x) = forward x;

define weaveValues private overload;
forceinline weaveValues(between, forward x, forward ..xs)
    = forward x, between, ..weaveValues(between, ..xs);
forceinline weaveValues(between, forward x, forward y)
    = forward x, between, y;
forceinline weaveValues(between, forward x) = forward x;
forceinline weaveValues(between) = ;

define reverseValues private overload;
forceinline reverseValues() = ;
forceinline reverseValues(forward x, forward ..xs) = forward ..reverseValues(..xs), x;


/// @section  countOccurrences, firstValue 

define countOccurrences private overload;
forceinline countOccurrences(value) = 0;
[value1, value2]
forceinline countOccurrences(#value1, #value2, forward ..xs)
    = countOccurrences(#value1, ..xs);
[value]
forceinline countOccurrences(#value, #value, forward ..xs)
    = 1 + countOccurrences(#value, ..xs);

forceinline firstValue(forward a, ..rest) = forward a;

forceinline restValues(a, forward ..rest) = forward ..rest;

forceinline lastValue(..a, forward last) = forward last;



/// @section  replicateValue, allValues?, anyValues?, equalValues?, inValues? 

[n when n >= 0]
define replicateValue(a, #n) private overload;

[n when n > 0]
forceinline replicateValue(a, #n) = a, ..replicateValue(a, #(n-1));
[n when n == 0]
forceinline replicateValue(a, #n) = ;

forceinline allValues?(pred, ..rest) {
    ..for (x in rest) {
        if (not pred(x))
            return false;
    }
    return true;
}

forceinline anyValues?(pred, ..rest) {
    ..for (x in rest) {
        if (pred(x))
            return true;
    }
    return false;
}

forceinline equalValues?(a, ..rest) = allValues?(x => a == x, ..rest);

inValues?(a, ..rest) = anyValues?(x => a == x, ..rest);



/// @section  capture/forward values 

// captureValue, forwardValue, capturedRef

private record CapturedLValue[T] (
    ptr : Pointer[T]
);

private record CapturedRValue[T] (
    value: T
);

define CapturedValue?(a) : Bool private overload;

CapturedValue?(a) : Bool = false;
[T]
CapturedValue?(#CapturedLValue[T]) : Bool = true;
[T]
CapturedValue?(#CapturedRValue[T]) : Bool = true;

define captureValue(v) private overload;
forceinline captureValue(rvalue x) = CapturedRValue(move(x));
forceinline captureValue(ref x) = CapturedLValue(@x);

[V when CapturedValue?(V)]
define forwardValue(v:V) private overload;
[T] forceinline forwardValue(x:CapturedRValue[T]) = move(x.value);
[T] forceinline forwardValue(x:CapturedLValue[T]) = ref x.ptr^;

[V when CapturedValue?(V)]
define capturedRef(v:V) private overload;
[T] forceinline capturedRef(x:CapturedRValue[T]) = ref x.value;
[T] forceinline capturedRef(x:CapturedLValue[T]) = ref x.ptr^;

// captureValues, forwardValues, capturedRefs

forceinline captureValues(forward ..args) = Tuple(..mapValues(captureValue, ..args));

[..T when allValues?(CapturedValue?, ..T)]
forceinline forwardValues(x:Tuple[..T]) =
    forward ..mapValues(forwardValue, ..unpackTupleRef(x));

[..T when allValues?(CapturedValue?, ..T)]
forceinline capturedRefs(x:Tuple[..T]) =
    forward ..mapValues(capturedRef, ..unpackTupleRef(x));



/// @section  expand values from sequence or iterator  
[S, n when Sequence?(S)]
sequenceValues(seq: S, #n) = forward ..iteratorValues(iterator(seq), #n);

[I, n when Iterator?(I)]
define iteratorValues(iter:I, #n) private overload;

iteratorValues(iter, #0) = ;
[n when n > 0]
iteratorValues(iter, #n) {
    var v = nextValue(iter);
    assert["boundsChecks"](hasValue?(v));
    return forward ..getValue(v), ..iteratorValues(iter, #(n-1));
}



/// @section  iterate over two sets of values in tandem 
define eachValue2 private overload;

[n when n > 0]
eachValue2(fn, #n, forward x, forward ..xs) {
    fn(x, nthValue(#(n-1), ..xs));
    return ..eachValue2(fn, #(n-1), ..withoutNthValue(#(n-1), ..xs));
}
eachValue2(fn, #0, forward ..xs) { }

define mapValues2 private overload;
[n when n > 0]
mapValues2(fn, #n, forward x, forward ..xs)
    = forward fn(x, nthValue(#(n-1), ..xs)),
      ..mapValues2(fn, #(n-1), ..withoutNthValue(#(n-1), ..xs));
mapValues2(fn, #0, forward ..xs) = ;



/// @section  treat multiple #tuple values as key-values pairs 

define assocValue private overload;

[key]
assocValue(#key, kv, forward ..kvs) = forward ..assocValue(#key, ..kvs);

[key, ..T]
assocValue(#key, forward kv: Tuple[Static[key], ..T], ..kvs)
    = forward ..restValues(..unpack(kv));


[key]
define assocValue?(#key, ..kvs) : Bool private overload;
[key]
assocValue?(#key) : Bool = false;
[key]
assocValue?(#key, kv, ..kvs) : Bool = assocValue?(key, ..kvs);
[key, ..T]
assocValue?(#key, kv: Tuple[Static[key], ..T], ..kvs) : Bool = true;

define assocCountValues private overload;
[key]
assocCountValues(#key) = -1;
[key]
assocCountValues(#key, kv, ..kvs) = assocCountValues(key, ..kvs);
[key, ..T]
assocCountValues(#key, kv: Tuple[Static[key], ..T], ..kvs) = countValues(..T);



/// @section  find the index of a value within a value list 

private define _valueIndex;
[n, value, other]
_valueIndex(#n, #value, #other, ..etc)
    = _valueIndex(#(n+1), #value, ..etc);
[n, value]
_valueIndex(#n, #value, #value, ..etc) = n;
[value]
valueIndex(#value, ..etc) = _valueIndex(#0, #value, ..etc);
