
/// @section  copy*Memory*, move*Memory*, *assign*Memory* for POD types 

[P]
private forceinline copyPODs(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    memmove(destBegin, srcBegin, SizeT(RawPointer(srcEnd)-RawPointer(srcBegin)));
}
[P]
private forceinline copyNonovPODs(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    memcpy(destBegin, srcBegin, SizeT(RawPointer(srcEnd)-RawPointer(srcBegin)));
}

[P when BitwiseCopiedType?(P)]
forceinline copyNonoverlappingMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseMovedType?(P)]
forceinline moveMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyPODs(destBegin, srcBegin, srcEnd);
    var destEnd = destBegin + (srcEnd - srcBegin);
    if (destBegin <= srcBegin)
        resetMemoryUnsafe(max(destEnd, srcBegin), srcEnd);
    else
        resetMemoryUnsafe(srcBegin, min(srcEnd, destBegin));
}
[P when BitwiseMovedType?(P) and ResetDoesNothingType?(P)]
forceinline moveMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseMovedType?(P)]
forceinline moveMemoryUnsafe(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseMovedType?(P)]
forceinline moveNonoverlappingMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
    resetMemoryUnsafe(srcBegin, srcEnd);
}
[P when BitwiseMovedType?(P) and ResetDoesNothingType?(P)]
forceinline moveNonoverlappingMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseMovedType?(P)]
forceinline moveNonoverlappingMemoryUnsafe(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseAssignedType?(P)]
forceinline assignNonoverlappingMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
}
[P when BitwiseMoveAssignedType?(P)]
forceinline moveAssignNonoverlappingMemory(destBegin:Pointer[P], srcBegin:Pointer[P], srcEnd:Pointer[P]) : {
    copyNonovPODs(destBegin, srcBegin, srcEnd);
}


/// @section  resetMemoryUnsafe, destroyMemory for POD 

[P when ResetDoesNothingType?(P)]
forceinline resetMemoryUnsafe(begin:Pointer[P], end:Pointer[P]) : { }

[P when DestroyDoesNothingType?(P)]
forceinline destroyMemory(begin:Pointer[P], end:Pointer[P]) : { }


/// @section  value semantics for POD 

define copyPOD;

[P] forceinline copyPOD(x: P) --> returned: P { memcpy(@returned, @x, TypeSize(P)); }
forceinline copyPOD(x: Bool) --> returned: Bool { bitcopy(returned, x); }
[N when Numeric?(N)]
forceinline copyPOD(x: N) --> returned: N { bitcopy(returned, x); }
[E when Enum?(E)]
forceinline copyPOD(x: E) --> returned: E { bitcopy(returned, x); }
[T]
forceinline copyPOD(x: Pointer[T]) --> returned: Pointer[T] { bitcopy(returned, x); }
[In, Out]
forceinline copyPOD(x: CodePointer[In, Out]) --> returned: CodePointer[In, Out]
    { bitcopy(returned, x); }
[C,V,I,O]
forceinline copyPOD(x: ExternalCodePointer[C,V,I,O])
    --> returned: ExternalCodePointer[C,V,I,O]
    { bitcopy(returned, x); }

[P when DestroyDoesNothingType?(P)]
forceinline destroy(x: P) : {}
[P when BitwiseMovedType?(P)]
forceinline moveUnsafe(x: P) : P = copyPOD(x);
[P when ResetDoesNothingType?(P)]
forceinline resetUnsafe(x: P) : { }
[P when BitwiseCopiedType?(P)]
forceinline P(x: P) --> returned: P = copyPOD(x);
[P when BitwiseAssignedType?(P)]
forceinline assign(ref x: P, y: P) : { x <-- copyPOD(y); }

