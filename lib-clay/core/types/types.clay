public import core.types.platform.*;
public import __operators__.(typeToRValue, typesToRValues);


/// @section  types 

alias CBool = Bool;

alias Byte = UInt8;

alias CChar = Int8;
alias CUChar = UInt8;

alias Short = Int16;
alias UShort = UInt16;
alias CShort = Int16;
alias CUShort = UInt16;

alias Int = Int32;
alias UInt = UInt32;
alias CInt = Int32;
alias CUInt = UInt32;

alias Long = Int64;
alias ULong = UInt64;
// CLong and CULong are different on different platforms

alias CLongLong = Int64;
alias CULongLong = UInt64;

alias Float = Float32;
alias Double = Float64;
alias LongDouble = Float80;
alias CFloat = Float32;
alias CDouble = Float64;

// CLongDouble is different on different platforms

alias ComplexFloat = Complex32;
alias ComplexDouble = Complex64;
alias ComplexLongDouble = Complex80;

alias CComplexFloat = ComplexFloat;
alias CComplexDouble = ComplexDouble;

alias IFloat = Imag32;
alias IDouble = Imag64;
alias ILongDouble = Imag80;

alias RawPointer = Pointer[Byte];
alias OpaquePointer = Pointer[Byte];

alias SizeT = UPtrInt;
alias SSizeT = PtrInt;

alias Opaque = Byte;



/// @section  Type 

[..T]
alias Type(..x:T) = ..T;



/// @section  typeToLValue, typeToRValue, typesToLValues, typesToRValues 

forceinline typeToLValue(a) = ref null(a)^;
[T] forceinline typeToRValue(#T) --> returned:T {}

forceinline typesToLValues(..a) = forward ..mapValues(typeToLValue, ..a);
forceinline typesToRValues(..a) = ..mapValues(typeToRValue, ..a);



/// @section  ByRef[T] - return-by-reference type helper from __primitives__ 

[T] RegularRecord?(#ByRef[T]) : Bool = false;



/// @section  ReturnType 

alias ReturnType(..x) = ..Type(..returnValues(..x));


private define returnValues;

[T] forceinline returnValues(ref first:T, forward ..rest) =
    typeToLValue(ByRef[T]), ..returnValues(..rest);

[T] forceinline returnValues(rvalue first:T, forward ..rest) =
    typeToLValue(T), ..returnValues(..rest);

forceinline returnValues() = ;



/// @section  returnTypeToValue, returnTypesToValues 

define returnTypeToValue private overload;
[T] forceinline returnTypeToValue(#T) = typeToRValue(T);
[T] forceinline returnTypeToValue(#ByRef[T]) = ref typeToLValue(T);

forceinline returnTypesToValues(..a) = forward ..mapValues(returnTypeToValue, ..a);



/// @section  integer limits 

define Least;
define Greatest;

forceinline Least(#Int8) : Int8 = -128_ss;
forceinline Greatest(#Int8) : Int8 = 127_ss;

forceinline Least(#UInt8) : UInt8 = 0_uss;
forceinline Greatest(#UInt8) : UInt8 = 255_uss;

forceinline Least(#Int16) : Int16 = -0x8000_s;
forceinline Greatest(#Int16) : Int16 = 0x7FFF_s;

forceinline Least(#UInt16) : UInt16 = 0_us;
forceinline Greatest(#UInt16) : UInt16 = 0xFFFF_us;

forceinline Least(#Int32) : Int32 = -0x8000_0000_i;
forceinline Greatest(#Int32) : Int32 = 0x7FFF_FFFF_i;

forceinline Least(#UInt32) : UInt32 = 0_u;
forceinline Greatest(#UInt32) : UInt32 = 0xFFFF_FFFF_u;

forceinline Least(#Int64) : Int64 = -0x8000_0000_0000_0000_l;
forceinline Greatest(#Int64) : Int64 = 0x7FFF_FFFF_FFFF_FFFF_l;

forceinline Least(#UInt64) : UInt64 = 0_ul;
forceinline Greatest(#UInt64) : UInt64 = 0xFFFF_FFFF_FFFF_FFFF_ul;

forceinline Least(#Int128) : Int128 = wrapBitshl(1_ll, 127);
forceinline Greatest(#Int128) : Int128
    = numericSubtract(Least(Int128), 1ll);

forceinline Least(#UInt128) : UInt128 = 0_ull;
forceinline Greatest(#UInt128) : UInt128 = numericSubtract(0_ull, 1_ull);


/// @section  float limits 

define LeastPositive;
define LeastPositiveNormalized;
define GreatestPositiveFinite;

forceinline LeastPositive(#Float32) : Float32 = 0x0.0000_02p-126f;
forceinline LeastPositiveNormalized(#Float32) : Float32 = 0x1.0000_00p-126f;
forceinline GreatestPositiveFinite(#Float32) : Float32 = 0x1.FFFF_FEp127f;

forceinline LeastPositive(#Float64) : Float64
    = 0x0.0000_0000_0000_1p-1022;
forceinline LeastPositiveNormalized(#Float64) : Float64
    = 0x1.0000_0000_0000_0p-1022;
forceinline GreatestPositiveFinite(#Float64) : Float64
    = 0x1.FFFF_FFFF_FFFF_Fp1023;

forceinline LeastPositive(#Float80) : Float80
    = 0x0.0000_0000_0000_0001p-16318l;
forceinline LeastPositiveNormalized(#Float80) : Float80
    = 0x1.0000_0000_0000_0000p-16382l;
forceinline GreatestPositiveFinite(#Float80) : Float80
    = 0x1.FFFF_FFFF_FFFF_FFFEp16383l;

forceinline LeastPositive(#Imag32) : Imag32
    = numericConvert(Imag32,LeastPositive(Float32));
forceinline LeastPositiveNormalized(#Imag32) : Imag32
    = numericConvert(Imag32,LeastPositiveNormalized(Float32));
forceinline GreatestPositiveFinite(#Imag32) : Imag32
    = numericConvert(Imag32,GreatestPositiveFinite(Float32));

forceinline LeastPositive(#Imag64) : Imag64
    = numericConvert(Imag64,LeastPositive(Float64));
forceinline LeastPositiveNormalized(#Imag64) : Imag64
    = numericConvert(Imag64,LeastPositiveNormalized(Float64));
forceinline GreatestPositiveFinite(#Imag64) : Imag64
    = numericConvert(Imag64,GreatestPositiveFinite(Float64));

forceinline LeastPositive(#Imag80) : Imag80
    = numericConvert(Imag80,LeastPositive(Float80));
forceinline LeastPositiveNormalized(#Imag80) : Imag80
    = numericConvert(Imag80,LeastPositiveNormalized(Float80));
forceinline GreatestPositiveFinite(#Imag80) : Imag80
    = numericConvert(Imag80,GreatestPositiveFinite(Float80));


/// @section  valueSize() 

[T] alias valueSize(x:T) = TypeSize(T);


/// @section  newtypes

[T] NewType?(#T) = (!=)(Type(T), BaseType(T));

[T] baseCast(x:T) = bitcast(BaseType(T), x);
