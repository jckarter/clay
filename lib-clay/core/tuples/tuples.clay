import __operators__;


/// @section  Tuple? 

[T]
define Tuple?(#T) : Bool private overload;
override Tuple?(x) : Bool = false;
[..T] override Tuple?(#Tuple[..T]) : Bool = true;



/// @section  TupleElements 

[..T] TupleElements(#Tuple[..T]) = ..T;



/// @section  staticIndex 

[..T, i]
forceinline override staticIndex(a:Tuple[..T], #i) =
    ref tupleRef(a, #SizeT(i));



/// @section  unpackTuple, unpackTupleRef 

forceinline unpackTuple(x) = ..unpackTupleRef(x);

[..T]
forceinline unpackTupleRef(x:Tuple[..T]) = ref ..tupleElements(x);



/// @section  unpack, unpackRef 

define unpackRef private overload;

forceinline override unpackRef(x) = ref x;
[..T]
forceinline override unpackRef(x:Tuple[..T]) = ref ..unpackTupleRef(x);

forceinline unpack(x) = ..unpackRef(x);



/// @section  Tuple type inferring constructor 

[..T]
alias override Tuple(..args:T) : Tuple[..T] = Tuple[..T](..args);



/// @section  basic constructor 

[..T]
alias override Tuple[..T](..args:T) --> returned:Tuple[..T] {
    ..unpackTupleRef(returned) <-- ..args;
}



/// @section  default constructor 

[..T]
forceinline override Tuple[..T]() --> returned:Tuple[..T] {
    initializeMulti(..tupleElements(returned));
}

[..A]
private forceinline initializeMulti(..args:A) {
    ..args <-- ..initializeTypes(..A);
}

private define initializeTypes;
forceinline override initializeTypes(A, ..B) = A(), ..initializeTypes(..B);
forceinline override initializeTypes() = ;



/// @section  copy constructor 

[..T when not allValues?(BitwiseCopiedType?, ..T)]
forceinline override Tuple[..T](src:Tuple[..T]) --> returned:Tuple[..T] {
    ..tupleElements(returned) <-- ..tupleElements(src);
}



/// @section  moveUnsafe, resetUnsafe 

[..T when not allValues?(BitwiseMovedType?, ..T)]
forceinline override moveUnsafe(src:Tuple[..T]) --> returned:Tuple[..T] {
    alias n = TupleElementCount(Tuple[..T]);
    ..for (i in staticIntegers(#n))
        staticIndex(returned, i) <-- moveUnsafe(staticIndex(src, i));
}

[..T when not allValues?(ResetDoesNothingType?, ..T)]
forceinline override resetUnsafe(a:Tuple[..T]) : {
    ..for (x in tupleElements(a))
        resetUnsafe(x);
}



/// @section  destroy 

[..T when not allValues?(DestroyDoesNothingType?, ..T)]
forceinline override destroy(a:Tuple[..T]) : {
    ..for (x in tupleElements(a))
        destroy(x);
}



/// @section  assign 

[..T when not allValues?(BitwiseAssignedType?, ..T)]
forceinline override assign(ref dest:Tuple[..T], ref src:Tuple[..T]) : {
    alias n = TupleElementCount(Tuple[..T]);
    ..for (i in staticIntegers(#n))
        assign(staticIndex(dest, i), staticIndex(src, i));
}



/// @section  equals? 

[..T, ..U when countValues(..T) != countValues(..U)]
forceinline override equals?(a:Tuple[..T], b:Tuple[..U]) : Bool = false;

[..T, ..U when countValues(..T) == countValues(..U)
    and allValues?(x -> x,
        ..mapValues2((t, u) -> CallDefined?((==), t, u),
            #countValues(..T), ..T, ..U))]
forceinline override equals?(a:Tuple[..T], b:Tuple[..U]) : Bool {
    alias n = TupleElementCount(Tuple[..T]);
    ..for (i in staticIntegers(#n)) {
        if (not equals?(staticIndex(a, i), staticIndex(b, i)))
            return false;
    }
    return true;
}

[..T]
forceinline override equals?(a:Tuple[..T], b:Tuple[..T]) : Bool {
    alias n = TupleElementCount(Tuple[..T]);
    ..for (i in staticIntegers(#n)) {
        if (not equals?(staticIndex(a, i), staticIndex(b, i)))
            return false;
    }
    return true;
}



/// @section  lesser? 

[..T]
forceinline override lesser?(a:Tuple[..T], b:Tuple[..T]) : Bool {
    alias n = TupleElementCount(Tuple[..T]);
    ..for (i in staticIntegers(#n)) {
        ref av = staticIndex(a, i);
        ref bv = staticIndex(b, i);
        if (lesser?(av, bv))
            return true;
        if (lesser?(bv, av))
            return false;
    }
    return false;
}



/// @section  tupleLiteral 

alias override __operators__.tupleLiteral(..args) = Tuple(..args);
