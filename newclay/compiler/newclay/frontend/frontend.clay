import newclay.core.*;
import newclay.codegen.c.*;
import newclay.loader.*;
import newclay.platforms.*;
import maybe.*;
import io.paths.*;
import io.files.raw.*;
import libc.(exit, atexit);
// XXX windows
import unix.(fork, execvp, waitpid, mkstemp, unlink, WIFSIGNALED, WIFEXITED, WTERMSIG, WEXITSTATUS);

// XXX replace hostTargetInfo() hardcodes with configurable target


//
// parseFrontendOptions
//

enum FrontendOutputMode {
    EXECUTABLE_MODE,
    OBJECT_MODE,
    ASSEMBLY_MODE,
    C_SOURCE_MODE,
}

record FrontendOptions (
    modulePaths: Vector[String],
    cDialect: Maybe[CDialect],
    cFlags: Vector[String],
    outputMode: Maybe[FrontendOutputMode],
    outputFile: Maybe[String],
    inputFile: Maybe[String],
);

initUniqueOption(maybeOption, value, errorFn) {
    maybe(maybeOption,
        oldOption ref=> { errorFn(oldOption); },
        () ref=> {
            maybeOption = Maybe(value);
        },
    );
}

initOutputMode(modeVar, mode) {
    initUniqueOption(modeVar, mode, x ref=> {
        optionError("only one of -c, -S, -E may be specified");
    });
}

parseFrontendOptions() {
    var options = FrontendOptions();

    parseOptions(
        ("-I", PrefixOption, o ref=> {
            push(options.modulePaths, String(requireParameter(o, "no path given for -I")));
        }),
        ("-o", WordOption, o ref=> {
            var outputFile = requireParameter(o, "no path given for -o");
            initUniqueOption(options.outputFile, String(outputFile), oldOutputFile ref=> {
                optionError("multiple output paths given: ", oldOutputFile, ", ", outputFile);
            });
        }),
        ("-cc", WordOption, o ref=> {
            var dialect = requireParameter(o, "no dialect given for -cc");
            switch (dialect) {
            case "msvc":
                initUniqueOption(options.cDialect, MSVC_DIALECT, x ref=> {
                    optionError("multiple -cc dialects given");
                });
                break;
            case "gcc":
                initUniqueOption(options.cDialect, GCC_DIALECT, x ref=> {
                    optionError("multiple -cc dialects given");
                });
                break;
            default:
                optionError("unknown -cc dialect ", dialect);
                break;
            }
        }),
        ("-cflags{", PrefixOption, o ref=> {
            requireParametersUntilBrace(o, options.cFlags, "no closing brace for -cflags{}");
        }),
        ("-c", WordOption, o ref=> {
            initOutputMode(options.outputMode, OBJECT_MODE);
        }),
        ("-S", WordOption, o ref=> {
            initOutputMode(options.outputMode, ASSEMBLY_MODE);
        }),
        ("-E", WordOption, o ref=> {
            initOutputMode(options.outputMode, C_SOURCE_MODE);
        }),
        ("--help", WordOption, o ref=> { usage(); }),
        ("-help",  WordOption, o ref=> { usage(); }),
        ("/?",     WordOption, o ref=> { usage(); }),
        inputFile ref=> {
            initUniqueOption(options.inputFile, String(inputFile), oldInputFile ref=> {
                optionError("multiple input paths given: ", oldInputFile, ", ", inputFile);
            });
        },
    );

    validateFrontendOptions(options);
    return move(options);
}

validateFrontendOptions(options) {
    if (nothing?(options.inputFile)) {
        println("no input file specified");
        println();
        usage();
    }

    var inputFile = just(options.inputFile);

    // XXX must occur before outputFile
    if (nothing?(options.outputMode))
        options.outputMode = Maybe(EXECUTABLE_MODE);

    if (nothing?(options.outputFile))
        options.outputFile = Maybe(defaultOutputFileName(options, inputFile));

    if (nothing?(options.cDialect))
        options.cDialect = Maybe(hostTargetInfo().cDialect);

    var dirname = pathDirname(inputFile);
    if (not empty?(dirname))
        push(options.modulePaths, dirname);
    push(options.modulePaths, String("."));
}

defaultOutputFileExtension(options) {
    switch (just(options.outputMode)) {
    case EXECUTABLE_MODE:
        if (hostTargetInfo().platformFamily == WINDOWS_PLATFORM_FAMILY)
            return ".exe";
        else
            return "";
    case OBJECT_MODE:
        if (hostTargetInfo().platform == MSVC_PLATFORM)
            return ".obj";
        else
            return ".o";
    case ASSEMBLY_MODE:
        if (hostTargetInfo().platform == MSVC_PLATFORM)
            return ".asm";
        else
            return ".s";
    case C_SOURCE_MODE:
        return ".c";
    default:
        assert(false, "invalid output mode");
        return "";
    }
}

defaultOutputFileName(options, inputFile) {
    var dirname, basename = ...slicedPath(inputFile);
    var e = reverseFind(basename, '.');
    var name = if (e != begin(basename))
        String(coordinateRange(begin(basename), e - 1))
    else
        String(basename);

    return name + defaultOutputFileExtension(options);
}

usage() {
    println("usage: clay <options> <clayfile>");
    println("options:");
    println("  -o <filename>        - specify output file name");
    println("  -I<path>             - add <path> to module search path");
    println("  -cc gcc|msvc         - generate code for GCC or MSVC C dialect");
    println("  -cflags{ <flags> }   - pass compiler flags directly to C compiler");
    println("  -E                   - emit C source");
    println("  -S                   - emit assembly language");
    println("  -c                   - emit object file");
    exit(2);
}


//
// compiler invocation
//

private var _temporarySourceName = String();

private _deleteTemporarySourceFile() {
    unlink(cstring(_temporarySourceName));
}

private temporarySourceFile() {
    _temporarySourceName = String("claysource.XXXXXX");
    var fd = mkstemp(cstring(_temporarySourceName));
    if (fd < 0)
        genericError("unable to create temporary file");
    atexit(makeCCodePointer(_deleteTemporarySourceFile));
    return _temporarySourceName, RawFile(fd, true);
}

compileProgramWithOptions(options:FrontendOptions) {
    var sourceOnly? = just(options.outputMode) == C_SOURCE_MODE;
    var sourceFileName = uninitializedUnsafe(String);
    var sourceFile = uninitializedUnsafe(RawFile);

    if (sourceOnly?) {
        sourceFileName <-- just(options.outputFile);
        sourceFile <-- RawFile(sourceFileName, CREATE);
    } else {
        sourceFileName, sourceFile <-- ...temporarySourceFile();
    }

    codegenStandaloneProgramTo(CodegenConfig(just(options.cDialect)), sourceFile);

    if (not sourceOnly?) {
        switch (just(options.cDialect)) {
        case GCC_DIALECT:
            invokeGCC(options, sourceFileName);
            return;
        case MSVC_DIALECT:
            invokeMSVC(options, sourceFileName);
            return;
        default:
            assert(false, "invalid C dialect");
            return;
        }
    }
}

private invokeGCC(options, sourceFileName) {
    var argv = Vector[String]();
    // XXX configurable gcc location
    push(argv, String("gcc"));
    switch (just(options.outputMode)) {
    case EXECUTABLE_MODE:
        break;
    case OBJECT_MODE:
        push(argv, String("-c"));
        break;
    case ASSEMBLY_MODE:
        push(argv, String("-S"));
        break;
    default:
        assert(false, "invalid output mode for compiler");
        break;
    }
    push(argv, String("-o"));
    push(argv, just(options.outputFile));
    push(argv, String("-x"));
    push(argv, String("c"));
    push(argv, options.cFlags);

    // gcc doesn't support -- to end option parsing
    if (sourceFileName[0] == '-')
        sourceFileName = "./" + sourceFileName;

    push(argv, sourceFileName);
    observe(argv);

    var cargv = map(cstring, argv);
    push(cargv, null(CChar));

    var pid = fork();
    if (pid == 0) {
        execvp(cstring(argv[0]), begin(cargv));
        // XXX include strerror
        genericError("failed to execute gcc");
    } else if (pid < 0)
        // XXX include strerror
        genericError("failed to fork to execute gcc");

    var statLoc = 0;
    var r = waitpid(pid, &statLoc, 0);
    if (r < 0)
        // XXX include strerror
        genericError("failed to get status of gcc process");
    if (WIFSIGNALED(statLoc))
        genericError("gcc process exited abnormally with signal ", WTERMSIG(statLoc));
    if (WIFEXITED(statLoc) and WEXITSTATUS(statLoc) != 0)
        genericError("gcc process exited with code ", WEXITSTATUS(statLoc));
}

private invokeMSVC(options, sourceFileName) {
    optionError("compilation with MSVC not yet supported. use -E to generate C source");
}


//
// options parser
//

record Options (
    more?: Bool,
    argc: SizeT,
    argv: Pointer[Pointer[CChar]],
    arg: Pointer[CChar],
);

overload Options(argc, argv) = Options(
    argc != 0,
    SizeT(argc),
    argv,
    if (argc == 0) null(CChar) else argv[0]
);

hasMoreParameters?(o:Options) = o.more?;
currentParameter(o:Options) = CStringRef(o.arg);
nextParameter(o:Options) {
    var result = currentParameter(o);
    o.argc -= 1;
    o.argv += 1;
    if (o.argc > 0) {
        if (CStringRef(o.argv[0]) == "--") {
            o.argc -= 1;
            o.argv += 1;
            o.more? = false;
        } else
            o.arg = o.argv[0];
    } else
        o.more? = false;
    return result;
}
tailParameters(o:Options) = mapped(CStringRef, coordinateRange(o.argv, o.argv + o.argc));

requireParameter(o:Options, ...msg) {
    if (not hasMoreParameters?(o))
        optionError(...msg);
    return nextParameter(o);
}

requireParametersUntilBrace(o:Options, into:Vector[String], ...msg) {
    while (true) {
        var s = requireParameter(o, ...msg);
        if (size(s) > 0 and s[size(s) - 1] == '}') {
            if (size(s) > 1)
                push(into, String(sliceUpto(s, size(s) - 1)));
            break;
        }
        push(into, String(s));
    }
}

[S | String?(S)]
currentParameter?(o:Options, prefix:S) {
    if (currentParameter(o) == prefix) {
        nextParameter(o);
        return true;
    }
    return false;
}

[S | String?(S)]
prefixParameter?(o:Options, prefix:S) {
    var param = currentParameter(o);
    var prefixSize = size(prefix);
    if (size(param) == prefixSize and param == prefix) {
        nextParameter(o);
        return true;
    }
    if (size(param) > prefixSize and prefix == slicedUpto(param, prefixSize)) {
        o.arg += prefixSize;
        return true;
    }
    return false;
}

parseArgcArgv(argc, argv, ...specs) {
    var options = Options(argc, argv);

    while (hasMoreParameters?(options)) {
        tryOptions(options, ...specs);
    }
    tryTailParameters(options, ...specs);
}

parseOptions(...specs) {
    var argc, argv = ...getArgcArgv();
    assert(argc >= 1, "argc must be at least 1");
    parseArgcArgv(argc - 1, argv + 1, ...specs);
}

procedure WordOption;
procedure PrefixOption;

OptionSpec?(X, O) = false;
[S, O, F | String?(S) and CallDefined?(call, F, Options)]
overload OptionSpec?(static Tuple[S, Static[O], F], static O) = true;

private tryOptions(options) {
    optionError("unknown option: ", currentParameter(options));
}

[F | CallDefined?(call, F, CStringRef)]
overload tryOptions(options, defaultFn:F) {
    var param = nextParameter(options);
    if (size(param) > 0 and param[0] == '-')
        optionError("unknown option: ", currentParameter(options));
    defaultFn(param);
}

[O | OptionSpec?(O, PrefixOption)]
overload tryOptions(options, spec:O, ...specs) {
    ref name, _, fn = ...unpack(spec);
    if (prefixParameter?(options, name))
        fn(options);
    else
        tryOptions(options, ...specs);
}
[O | OptionSpec?(O, WordOption)]
overload tryOptions(options, spec:O, ...specs) {
    ref name, _, fn = ...unpack(spec);
    if (currentParameter?(options, name))
        fn(options);
    else
        tryOptions(options, ...specs);
}

private tryTailParameters(options) {
    optionError("invalid parameter: ", currentParameter(options));
}

overload tryTailParameters(options, a, ...b) { tryTailParameters(options, ...b); }

[F | CallDefined?(call, F, CStringRef)]
overload tryTailParameters(options, defaultFn:F) {
    for (param in tailParameters(options))
        defaultFn(param);
}


