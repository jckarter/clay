import newclay.ast as ast;
import newclay.ir as ir;
import newclay.analysis.*;
import newclay.evaluator.(mangleString, qualifiedValueString, printQualifiedTo, printQualifiedSymbolTo, stringSize);
import newclay.diagnostics.(computeLocation);
import newclay.optimizer.*;
import newclay.lifetime.*;
import newclay.core.*;
import newclay.common.*;
import newclay.hooks.*;
import maybe.*;
import printer.formatter.*;
import numbers.floats.*;

record CodegenFunction (
    mangledName:String, // _clay__whatever
    signature:Maybe[String], // static void _clay__whatever(...)
    definition:Maybe[String], // { ... }
);
overload CodegenFunction(mangledName)
    = CodegenFunction(mangledName, nothing(String), nothing(String));

enum CompoundKind { PRIMITIVE_TYPE, UNION_TYPE, STRUCT_TYPE }

record CodegenLLType (
    preTypeName:String,
    postTypeName:String,
    compoundKind:CompoundKind, // forward declared as union or struct?
    definition:Maybe[String],
    dependencies:Vector[Value],
);
overload CodegenLLType(preName, postName, compoundKind)
    = CodegenLLType(preName, postName, compoundKind, nothing(String), Vector[Value]());

record CodegenTypedef (
    mangledName:String,
    definition:String,
);
overload CodegenTypedef(c:CodegenContext, typeValue:Value)
    = CodegenTypedef(mangleType(typeValue), codegenTypedef(c, typeValue));

record CodegenConstant (
    mangledName:String, // _clay__constant_x
    definition:String, // const _clay__Type _clay_constant_x = ...;
);

enum CDialect { GCC_DIALECT, MSVC_DIALECT }

overload printTo(stream, d:CDialect) {
    switch (d) {
    case GCC_DIALECT:
        printTo(stream, "gcc");
        break;
    case MSVC_DIALECT:
        printTo(stream, "msvc");
        break;
    default:
        assert(false, "invalid c dialect");
        break;
    }
}

record CodegenConfig (
    dialect: CDialect,
);

record CodegenExternalEntryPointKey (
    specialization:Specialization,
    type:Value,
);

record CodegenExternalEntryPoint (
    // extern?
    name:String,
);

record CodegenContext (
    config: CodegenConfig,
    llTypes: HashMap[Value, CodegenLLType],
    llTypeOrder: Vector[Value],
    typedefs: HashMap[Value, CodegenTypedef],
    typedefOrder: Vector[Value],
    functions: HashMap[Specialization, CodegenFunction],
    functionOrder: Vector[Specialization],
    constructorFunction: Maybe[Specialization],
    destructorFunction: Maybe[Specialization],
    constants: HashMap[Value, CodegenConstant],
    constantOrder: Vector[Value],
    constantNames: NameAllocator,
    externals: HashMap[String, RTExternal],
    externalOrder: Vector[String],
    externalEntryPoints: HashMap[CodegenExternalEntryPointKey, CodegenExternalEntryPoint],
    externalEntryPointOrder: Vector[CodegenExternalEntryPointKey],
    globalNames: HashMap[RTGlobal, String],
);

overload CodegenContext(config:CodegenConfig) x:CodegenContext {
    x <-- CodegenContext();
    try {
        x.config = config;
    } catch (ex) {
        destroy(x);
        throw ex;
    }
}


//
// name mangling
//

mangleGlobal(name) = "_clay__" + mangleString(name);

mangleType(type:Value) = mangleGlobal(qualifiedValueString(type));

functionIdentifier(s:Specialization) {
    var identifier = qualifiedValueString(s.callable);
    printTo(identifier, '(');
    interleave(s.args,
        () ref=> { printTo(identifier, ","); },
        a  ref=> {
            printRTValueKindTo(identifier, a.kind);
            printQualifiedTo(identifier, a.type);
        },
    );
    printTo(identifier, ')');

    return move(identifier);
}

mangleFunction(s:Specialization) {
    return mangleGlobal(functionIdentifier(s));
}

mangleExternalEntryPoint(key:CodegenExternalEntryPointKey) {
    return mangleGlobal(printString(
        "external ", key.type, " ",
        functionIdentifier(key.specialization)
    ));
}

private getLLType(c:CodegenContext, llTypeValue:Value) {
    var namep = lookup(c.llTypes, llTypeValue);
    if (null?(namep)) {
        c.llTypes[llTypeValue] = CodegenLLType(
            ...getLLTypeName(c, llTypeValue),
            getLLTypeCompoundKind(llTypeValue),
        );
        push(c.llTypeOrder, llTypeValue);
        return ref c.llTypes[llTypeValue];
    } else
        return ref namep^;
}

private llTypeParams(llTypeValue:Value) = match(llTypeValue,
    Symbol, x ref=> ref x.params,
    MatchDefault, x ref=> {
        genericError("low-level type value ", llTypeValue, " must be a symbol");
        return ref variantAs(llTypeValue, Symbol).params;
    },
);

private llTypeName(c, llTypeValue) = getLLType(c, llTypeValue).typeName;

private getTypedef(c:CodegenContext, typeValue:Value) {
    var namep = lookup(c.typedefs, typeValue);
    if (null?(namep)) {
        c.typedefs[typeValue] = CodegenTypedef(c, typeValue);
        push(c.typedefOrder, typeValue);
        return ref c.typedefs[typeValue];
    } else
        return ref namep^;
}

private typedefName(c, typeValue) = getTypedef(c, typeValue).mangledName;

private addExternal(c:CodegenContext, e:RTExternal) {
    var symbolName = externalAttributes(e).symbolName;

    var externalp = lookup(c.externals, symbolName);
    if (null?(externalp)) {
        c.externals[symbolName] = e;
        push(c.externalOrder, symbolName);
    } else
        assert(externalp^ == e, "multiple external declarations cannot use the same symbol name");
}

private addFunction(
    c:CodegenContext,
    s:Specialization
) {
    assert(null?(lookup(c.functions, s)), "function added to codegen multiple times!");
    c.functions[s] = CodegenFunction(mangleFunction(s));
    push(c.functionOrder, s);
    return ref c.functions[s];
}

private getFunction(c:CodegenContext, s:Specialization) {
    var namep = lookup(c.functions, s);
    if (null?(namep)) {
        return ref addFunction(c, s);
    } else
        return ref namep^;
}

private functionName(c, s) = getFunction(c, s).mangledName;

private addExternalEntryPoint(c:CodegenContext, key:CodegenExternalEntryPointKey) {
    getFunction(c, key.specialization);
    c.externalEntryPoints[key] = CodegenExternalEntryPoint(mangleExternalEntryPoint(key));
    push(c.externalEntryPointOrder, key);
    return ref c.externalEntryPoints[key];
}

private getExternalEntryPoint(c:CodegenContext, s:Specialization, type:Value) {
    var key = CodegenExternalEntryPointKey(s, type);
    var extp = lookup(c.externalEntryPoints, key);
    if (null?(extp))
        return ref addExternalEntryPoint(c, key);
    else
        return ref extp^;
}

private externalEntryPointName(c, s, abi) = getExternalEntryPoint(c, s, abi).name;

// XXX need to differentiate components of variadic globals
private globalIdentifier(g) {
    var identifier = String("global ");
    printQualifiedSymbolTo(identifier, g.head, g.params);
    return move(identifier);
}

private globalName(c:CodegenContext, g:RTGlobal) {
    var namep = lookup(c.globalNames, g);
    if (null?(namep)) {
        c.globalNames[g] = mangleGlobal(globalIdentifier(g));
        return c.globalNames[g];
    } else
        return namep^;
}

private getConstant(c:CodegenContext, value:Value, definitionFn) {
    var constantp = lookup(c.constants, value);
    if (null?(constantp)) {
        ref constant = c.constants[value];
        constant.mangledName = mangleGlobal("constant " + allocateName(c.constantNames, printString(value)));
        constant.definition = definitionFn(constant);
        push(c.constantOrder, value);
        return ref constant;
    } else
        return ref constantp^;
}


//
// function codegen
//

record CodegenBodyContext (
    s:Specialization,
    bodyVars:HashMap[RTValue, String],
    bodyVarOrder:RTValues,
    bodyCode:String,
    indent:Int,
    localNames:NameAllocator,
);

overload CodegenBodyContext(s) = CodegenBodyContext(
    s,
    HashMap[RTValue, String](),
    RTValues(),
    String(),
    1,
    NameAllocator(),
);

private newLocalName(bc:CodegenBodyContext, value) {
    var name = maybe(value.name, n => n, () => String("temp"));
    bc.bodyVars[value] = mangleString(allocateName(bc.localNames, name)) + "_";
    push(bc.bodyVarOrder, value);
    return bc.bodyVars[value];
}

private localName(bc:CodegenBodyContext, value) {
    var namep = lookup(bc.bodyVars, value);
    if (null?(namep))
        return newLocalName(bc, value);
    else
        return namep^;
}

private externalName(c:CodegenContext, e:RTExternal) {
    addExternal(c, e);
    return externalAttributes(e).symbolName;
}

private cValue(c, value:Value) = match(value,
    BoolValue,   bv ref=> if (bv.value) String("1") else String("0"),
    IntValue,    iv ref=> cIntegerValue(c, iv),
    FloatValue,  fv ref=> cFloatValue(c, fv),
    CharValue,   cv ref=> printString(cv.value, "u"),
    StringValue, sv ref=> cStringValue(c, sv),
    MatchDefault, x ref=> { genericError("codegen of this value not yet supported"); return String(); },
);

private immediateValue(c, value:Value, bc, rtValue:RTValue) {
    if (staticType?(rtValue.type))
        return localName(bc, rtValue);
    else
        return cValue(c, value);
}

private cValueRef(c, value:Value, bc, rtValue:RTValue)
    = "&" + (if (immediateCValue?(value))
        localName(bc, rtValue)
    else
        cValue(c, value));

private valueDeref(c:CodegenContext, bc:CodegenBodyContext, value) {
    return match(value.referent,
        LocalVariable,     l ref=> localName(bc, value),
        ReferenceVariable, r ref=> "*" + localName(bc, value),
        RTExternal,        e ref=> externalName(c, e),
        RTGlobal,          g ref=> globalName(c, g),
        Value,             v ref=> immediateValue(c, v, bc, value),
    );
}

private valueRef(c:CodegenContext, bc:CodegenBodyContext, value) {
    return match(value.referent,
        ReferenceVariable, r ref=> localName(bc, value),
        RTGlobal,          g ref=> "&" + globalName(c, g),
        MatchDefault,      x ref=> "&" + localName(bc, value),
    );
}

private valueReturnByRef(c:CodegenContext, bc:CodegenBodyContext, value) {
    var name = localName(bc, value);
    assert(variantIs?(value.referent, ReferenceVariable), "return-by-reference result must be reference variable");
    return "&" + name;
}

codegenFunction(c:CodegenContext, s:Specialization) {
    ref body = just(s.body);
    var bc = CodegenBodyContext(s);

    for (node in body)
        codegenSubnode(c, bc, node);
    finalizeSpecialization(c, bc);
}

private printLocalDefinitionTo(stream, c, bc, a) {
    printTo(stream, typedefName(c, a.type), " ");
    assert(variable?(a) or immediateValue?(a), "generating a local for something that isn't a local variable or immediate value");
    if (referenceVariable?(a))
        printTo(stream, '*');
    printTo(stream, localName(bc, a));
    if (immediateValue?(a) and not staticType?(a.type))
        printTo(stream, " = ", valueDeref(c, bc, a));
}

private gccFunctionAttributes(c, s) {
    if (c.constructorFunction == Maybe(s))
        return String("__attribute__((constructor)) ");
    if (c.destructorFunction == Maybe(s))
        return String("__attribute__((destructor)) ");
    return String("");
}

private msvcFunctionAttributes(c, s) = String("");

private functionAttributes(c, s) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return gccFunctionAttributes(c, s);
    case MSVC_DIALECT:
        return msvcFunctionAttributes(c, s);
    default:
        assert(false);
        return String();
    }
}

private finalizeFunctionSignature(c, bc, function) {
    function.signature = Maybe(String());
    ref signature = just(function.signature);

    printTo(signature,
        functionAttributes(c, bc.s),
        "static void ", functionName(c, bc.s), "("
    );

    interleave(bc.s.internalArgs,
        () ref=> { printTo(signature, ", "); },
        a  ref=> {
            assert(not immediateValue?(a), "argument cannot have an immediate value");
            printLocalDefinitionTo(signature, c, bc, a);
            remove(bc.bodyVars, a);
        },
    );

    if (not empty?(bc.s.internalNamedResults)) {
        if (not empty?(bc.s.internalArgs))
            printTo(signature, ", ");

        interleave(bc.s.internalNamedResults,
            () ref=> { printTo(signature, ", "); },
            r  ref=> {
                assert(not immediateValue?(r), "return cannot have an immediate value");
                printLocalDefinitionTo(signature, c, bc, r);
                remove(bc.bodyVars, r);
            },
        );
    } else if (empty?(bc.s.internalArgs))
        printTo(signature, "void");

    printTo(signature, ")");
}

private finalizeFunctionDefinition(c, bc, function) {
    function.definition = Maybe(String());
    ref definition = just(function.definition);

    for (value in bc.bodyVarOrder) {
        if (not null?(lookup(bc.bodyVars, value))) {
            printToIndented(definition, 1);
            printLocalDefinitionTo(definition, c, bc, value);
            printTo(definition, ";\n");
        }
    }

    printlnTo(definition);
    printTo(definition, bc.bodyCode);
    printlnTo(definition, "#line 1 \"(clay generated)\"");
}

private finalizeSpecialization(c, bc) {
    ref function = getFunction(c, bc.s);

    finalizeFunctionSignature(c, bc, function);
    finalizeFunctionDefinition(c, bc, function);
}

private printToIndented(stream, indent, forward ...args) {
    for (i in range(indent))
        printTo(stream, "  ");
    printTo(stream, ...args);
}
overload printToIndented(bc:CodegenBodyContext, forward ...args) {
    printToIndented(bc.bodyCode, bc.indent, ...args);
}
overload printTo(bc:CodegenBodyContext, forward ...args) {
    printTo(bc.bodyCode, ...args);
}

private codegenSubnode(c, bc, node:ir.Node) {
    codegenLineAnnotation(c, bc, *node);
    codegenNode(c, bc, *node);
}

private procedure codegenLineAnnotation;

overload codegenLineAnnotation(c, bc, node) {
    printlnTo(bc.bodyCode, "#line 1 \"(clay generated)\"");
}
[N | CallDefined?(fieldRef, N, Static[#ast])]
overload codegenLineAnnotation(c, bc, node:N) {
    var path, line, column = ...ast.getFileLocation(node.ast);

    printTo(bc.bodyCode, "#line ", line, ' ');
    printTo(bc.bodyCode, cStringLiteral(path));
    printlnTo(bc.bodyCode);
}

private procedure codegenNode;

overload codegenNode(c, bc, node:ir.LiteralCodeBody) {
    if (node.ast.kind == ast.LITERAL_LLVM)
        genericError("__llvm__ procedures are not yet supported");
    if (node.ast.kind == ast.LITERAL_ASM)
        genericError("__asm__ procedures are not yet supported");

    printToIndented(bc);
    printLiteralCodeTo(c, bc, node.code);
    printlnTo(bc.bodyCode);
}

overload codegenNode(c, bc, node:ir.Not) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = !(", valueDeref(c, bc, node.input), ");\n");
}

overload codegenNode(c, bc, node:ir.AddressOf) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = ", valueRef(c, bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.AddressOfCode) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = &", functionName(c, node.specialization), ";\n");
}

overload codegenNode(c, bc, node:ir.AddressOfExternalCode) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = &",
        externalEntryPointName(c, node.specialization, node.output.type),
        ";\n"
    );
}

private codegenCall(c, bc, name, node) {
    printToIndented(bc, name, "(");

    interleave(node.inputs,
        () ref=> { printTo(bc, ", "); },
        i  ref=> { printTo(bc, valueRef(c, bc, i)); },
    );

    maybe(node.outputs, outputs ref=> {
        if (not empty?(node.inputs) and not empty?(outputs)) printTo(bc, ", ");
        interleave(outputs,
            () ref=> { printTo(bc, ", "); },
            o  ref=> {
                if (o.returnByRef?) {
                    printTo(bc, valueReturnByRef(c, bc, o.value));
                } else
                    printTo(bc, valueRef(c, bc, o.value));
            },
        );
    });

    printTo(bc, ");\n");
}

overload codegenNode(c, bc, node:ir.DereferenceCall) {
    var name = printString("(*(", valueDeref(c, bc, node.codePointer), "))");
    codegenCall(c, bc, name, node);
}

overload codegenNode(c, bc, node:ir.Call) {
    var name = functionName(c, node.specialization);
    codegenCall(c, bc, name, node);
}

overload codegenNode(c, bc, node:ir.If) {
    printToIndented(bc, "if (", valueDeref(c, bc, node.condition), ") {\n"); 
    bc.indent += 1;

    for (subnode in node.thenBody)
        codegenSubnode(c, bc, subnode);

    bc.indent -= 1;
    printToIndented(bc, "} else {\n");
    bc.indent += 1;

    for (subnode in node.elseBody)
        codegenSubnode(c, bc, subnode);

    bc.indent -= 1;
    printToIndented(bc, "}\n");
}

overload codegenNode(c, bc, node:ir.Statement) {
    for (subnode in node.body)
        codegenSubnode(c, bc, subnode);
}

overload codegenNode(c, bc, node:ir.Block) {
    for (subnode in node.body)
        codegenSubnode(c, bc, subnode);
    printToIndented(bc, "_clay_continue_", node.label, ":; _clay_break_", node.label, ":;\n");
}

overload codegenNode(c, bc, node:ir.While) {
    printToIndented(bc, "for (;;) {\n");
    bc.indent += 1;

    for (subnode in node.conditionBody)
        codegenSubnode(c, bc, subnode);

    printToIndented(bc, "if (!(", valueDeref(c, bc, node.condition), ")) break;\n");

    for (subnode in node.body)
        codegenSubnode(c, bc, subnode);

    bc.indent -= 1;
    printToIndented(bc, "_clay_continue_", node.label, ":; } _clay_break_", node.label, ":;\n");
}

overload codegenNode(c, bc, node:ir.Adopt) {
    assert(false, "ir.Adopt must be eliminated by lifetime analysis");
}

overload codegenNode(c, bc, node:ir.Consume) {
    assert(false, "ir.Consume must be eliminated by lifetime analysis");
}

overload codegenNode(c, bc, node:ir.Bind) {
    assert(variable?(node.output), "binding something that isn't a local variable: ", node.output, " <- ", node.input);
    assert(node.output.type == node.input.type, "types in bind must match");

    if (staticType?(node.output.type))
        return;

    if (localVariable?(node.output)) {
        printToIndented(bc, localName(bc, node.output), " = ", valueDeref(c, bc, node.input), ";\n");
    } else {
        printToIndented(bc, localName(bc, node.output), " = ", valueRef(c, bc, node.input), ";\n");
    }
}

overload codegenNode(c, bc, node:ir.Initialize) {
    assert(not immediateValue?(node.output), "cannot initialize an immediate value");
    assert(node.output.type == node.input.type, "types in initialize must match");

    if (staticType?(node.output.type))
        return;

    printToIndented(bc, valueDeref(c, bc, node.output), " = ", valueDeref(c, bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.Break) {
    printToIndented(bc, "goto _clay_break_", node.target, ";\n");
}

overload codegenNode(c, bc, node:ir.Continue) {
    printToIndented(bc, "goto _clay_continue_", node.target, ";\n");
}

overload codegenNode(c, bc, node:ir.Throw) {
    printToIndented(bc, "void abort();\n");
    printToIndented(bc, "abort();\n");
}

overload codegenNode(c, bc, node:ir.Nop) {
}

private cInt64Suffix(c) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "ll";
    case MSVC_DIALECT:
        return "i64";
    default:
        assert(false);
        return "";
    }
}

private cIntegerValue(c, iv) = match(iv,
    // XXX polymorphic static ints
    StaticIntValue, s ref=> printString(s.value),
    StaticUIntValue, s ref=> printString(s.value, "u"),
    Int64, n ref=> printString(n, cInt64Suffix(c)),
    UInt64, n ref=> printString(n, "u", cInt64Suffix(c)),
    UInt32, n ref=> printString(n, "u"),
    MatchDefault, n ref=> printString(n),
);

private cFloatConstant(c, fv) = ref getConstant(c, Value(fv), constant ref=>
    match(fv,
        Float32, n ref=> printString(
            "static const union _clay_Float32Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(8, '0', hex(floatBits(n))), "u };"
        ),
        Float64, n ref=> printString(
            "static const union _clay_Float64Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(16, '0', hex(floatBits(n))), "u", cInt64Suffix(c), " };"
        ),
    ),
);

private cFloatValue(c, fv) {
    ref constant = cFloatConstant(c, fv);
    return printString("(", constant.mangledName, ".asFloat)");
}

private cStringLiteral(s) {
    var result = String("\"");
    for (c in s) {
        switch (c) {
        case '\n':
            push(result, "\\n"); break;
        case '\r':
            push(result, "\\r"); break;
        case '\t':
            push(result, "\\t"); break;
        case '\a':
            push(result, "\\a"); break;
        case '\b':
            push(result, "\\b"); break;
        case '\f':
            push(result, "\\f"); break;
        case '\v':
            push(result, "\\v"); break;
        case '\\':
            push(result, "\\\\"); break;
        case '\"':
            push(result, "\\\""); break;
        default:
            if (Int(c) < 0x20 or Int(c) > 0x7e)
                printTo(result, "\\x", rightAlignedWith(2, '0', hex(UInt8(c))));
            else
                push(result, c);
            break;
        }
    }
    push(result, '\"');
    return move(result);
}

private cStringConstant(c, sv) = ref getConstant(c, Value(sv),
    constant ref=> {
        var stringName = constant.mangledName + "_string";
        return printString(
            "static const unsigned char ", stringName, "[] = ",
                cStringLiteral(sv.value), ";\n",
            "static const ", typedefName(c, stringConstantType()), " ", constant.mangledName,
            " = { ",
            "(", typedefName(c, uintType()), ")",
              cIntegerValue(c, IntValue(StaticUIntValue(UInt64(stringSize(sv.value))))), ", ",
            "(unsigned char*)", stringName, ", ",
            "(unsigned char*)", stringName, " + ", size(sv.value),
            " };",
        );
    }
);

private cStringValue(c, sv) = cStringConstant(c, sv).mangledName;


//
// lowlevel type codegen
//

codegenLLType(c:CodegenContext, llTypeValue:Value) {
    ref llType = getLLType(c, llTypeValue);
    llType.definition = Maybe(String());
    ref definition = just(llType.definition);

    if (ofLowLevelType?(llTypeValue, getHooks().llBoolType)
        or ofLowLevelType?(llTypeValue, getHooks().llIntegerType)
        or ofLowLevelType?(llTypeValue, getHooks().llFloatType)
        or ofLowLevelType?(llTypeValue, getHooks().llPointerType)
        or ofLowLevelType?(llTypeValue, getHooks().llCodePointerType)
        or ofLowLevelType?(llTypeValue, getHooks().llLiteralCType))
        return;
    else if (ofLowLevelType?(llTypeValue, getHooks().llArrayType))
        codegenArrayType(c, llType, llTypeValue, definition);
    else if (ofLowLevelType?(llTypeValue, getHooks().llTupleType))
        codegenTupleType(c, llType, llTypeValue, definition);
    else if (ofLowLevelType?(llTypeValue, getHooks().llUnionType))
        codegenUnionType(c, llType, llTypeValue, definition);
    else
        genericError("invalid low-level type ", llTypeValue);
}

private getLLTypeCompoundKind(llTypeValue:Value) {
    if (ofLowLevelType?(llTypeValue, getHooks().llArrayType)
        or ofLowLevelType?(llTypeValue, getHooks().llTupleType))
        return STRUCT_TYPE;
    if (ofLowLevelType?(llTypeValue, getHooks().llUnionType))
        return UNION_TYPE;
    return PRIMITIVE_TYPE;
}

private getLLTypeName(c, llTypeValue:Value) {
    if (ofLowLevelType?(llTypeValue, getHooks().llBoolType))
        return ...getBoolTypeName(c, llTypeValue);
    if (ofLowLevelType?(llTypeValue, getHooks().llIntegerType))
        return ...getIntTypeName(c, llTypeValue);
    if (ofLowLevelType?(llTypeValue, getHooks().llFloatType))
        return ...getFloatTypeName(c, llTypeValue);
    if (ofLowLevelType?(llTypeValue, getHooks().llPointerType))
        return ...getPointerTypeName(c, llTypeValue);
    if (ofLowLevelType?(llTypeValue, getHooks().llCodePointerType))
        return ...getCodePointerTypeName(c, llTypeValue);
    else if (ofLowLevelType?(llTypeValue, getHooks().llArrayType)
             or ofLowLevelType?(llTypeValue, getHooks().llTupleType))
        return printString("struct ", mangleType(llTypeValue)), String("");
    else if (ofLowLevelType?(llTypeValue, getHooks().llUnionType))
        return printString("union ", mangleType(llTypeValue)), String("");
    else if (ofLowLevelType?(llTypeValue, getHooks().llLiteralCType))
        return ...getLiteralTypeName(c, llTypeValue);
    else {
        genericError("invalid low-level type ", llTypeValue);
        return String(""), String("");
    }
}

private getBoolTypeName(c, llTypeValue) {
    if (not empty?(llTypeParams(llTypeValue)))
        genericError("low-level bool type ", llTypeValue, " must have no symbol parameters");
    return cIntegerType(c, true, 8), String("");
}

private getIntTypeName(c, llTypeValue) {
    ref params = llTypeParams(llTypeValue);
    if (size(params) != 2)
        genericError("low-level integer type ", llTypeValue, " must have two symbol parameters");

    var signed? = false;
    if (params[0] == getHooks().llSigned)
        signed? = true;
    else if (params[0] == getHooks().llUnsigned)
        signed? = false;
    else
        genericError("first symbol parameter of low-level integer type ", llTypeValue, " must be ", getHooks().llSigned, " or ", getHooks().llUnsigned);

    var bits = match(params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level integer type ", llTypeValue, " must be integer value");
            return 0_i64;
        }
    );

    return cIntegerType(c, signed?, bits), String("");
}

private getFloatTypeName(c, llTypeValue) {
    ref params = llTypeParams(llTypeValue);
    if (size(params) != 1)
        genericError("low-level float type ", llTypeValue, " must have one symbol parameter");

    var bits = match(params[0],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("symbol parameter of low-level float type ", llTypeValue, " must be integer value");
            return 0_i64;
        },
    );

    return cFloatType(bits), String("");
}

private getPointerTypeName(c, llTypeValue) {
    ref params = llTypeParams(llTypeValue);
    if (size(params) > 1)
        genericError("low-level pointer type ", llTypeValue, " must have zero or one symbol parameters");

    if (size(params) == 0)
        return String("void *"), String("");
    else {
        var targetTypeName = typedefName(c, params[0]);
        return printString(targetTypeName, " *"), String("");
    }
}

private getCodePointerTypeName(c, llTypeValue) {
    ref params = llTypeParams(llTypeValue);
    if (size(params) != 4)
        genericError("low-level code pointer type ", llTypeValue, " must have four symbol parameters");

    var abi = params[0];
    var variadic? = match(params[1],
        BoolValue, v ref=> v.value,
        MatchDefault, x ref=> {
            genericError("second symbol parameter of low-level code pointer type ", llTypeValue, " must be a boolean value");
            return false;
        },
    );
    var inputTypes = match(params[2],
        TupleValue, v ref=> v.elements,
        MatchDefault, x ref=> ValueList(params[2]),
    );
    var outputType = match(params[3],
        TupleValue, v ref=> nothing(Value),
        MatchDefault, x ref=> Maybe(params[3]),
    );

    var pre, post = String(), String();

    printPreFunctionTypeTo(pre, c, true,
        abi, variadic?, inputTypes, outputType,
    );
    printPostFunctionTypeTo(post, c, true,
        abi, variadic?, inputTypes, outputType,
    );
    return move(pre), move(post);
}

private literalStringParamValue(llTypeValue, paramValue) = match(paramValue,
    StringValue, s ref=> s.value,
    MatchDefault, x ref=> {
        genericError("low-level literal c type ", llTypeValue, " must have one or two string symbol parameters");
        return String("");
    },
);

private getLiteralTypeName(c, llTypeValue) {
    ref params = llTypeParams(llTypeValue);
    if (size(params) != 1 and size(params) != 2)
        genericError("low-level literal c type ", llTypeValue, " must have one or two string symbol parameters");

    var pre = literalStringParamValue(llTypeValue, params[0]);
    var post = if (size(params) == 2)
        literalStringParamValue(llTypeValue, params[1])
    else
        String("");

    return move(pre), move(post);
}

private codegenArrayType(c, llType, llTypeValue, definition) {
    ref params = llTypeParams(llTypeValue);
    assert(llType.compoundKind == STRUCT_TYPE, "array type must have STRUCT_TYPE compound kind");

    if (size(params) != 2)
        genericError("low-level array type ", llTypeValue, " must have two symbol parameters");

    var arraySize = match(params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level array type ", llTypeValue, " must be integer value");
            return 0_i64;
        },
    );

    push(llType.dependencies, lowLevelTypeValue(params[0]));

    printlnTo(definition, llType.preTypeName, " {");
    printToIndented(definition, 1, typedefName(c, params[0]),
        " array[", arraySize, "];\n",
    );
    printlnTo(definition, "};");
}

private aggregateMemberError(llTypeValue) {
    genericError("members of low-level aggregate type ", llTypeValue, " must be types or \"name:type\" pairs");
}

private aggregateMember(llTypeValue:Value, member:Value, index) {
    return ...match(member,
        Symbol, s ref=> {
            return printString("field", index), member;
        },
        TupleValue, tv ref=> {
            if (size(tv.elements) != 2)
                aggregateMemberError(llTypeValue);

            return ...match(tv.elements[0],
                StringValue, name ref=> {
                    return name.value, tv.elements[1];
                },
                MatchDefault, x ref=> {
                    aggregateMemberError(llTypeValue);
                    return String(), Value();
                },
            );
        },
        MatchDefault, x ref=> {
            aggregateMemberError(llTypeValue);
            return String(), Value();
        },
    );
}

private codegenTupleType(c, llType, llTypeValue, definition) {
    ref params = llTypeParams(llTypeValue);

    assert(llType.compoundKind == STRUCT_TYPE, "tuple type must have STRUCT_TYPE compound kind");

    printlnTo(definition, llType.preTypeName, " {");

    if (empty?(params) and c.config.dialect == MSVC_DIALECT)
        // XXX this is broken! empty tuple/unions should have size zero!
        // empty types really should be optimized away
        printToIndented(definition, 1, "char _pad_;\n");
    else for (member, i in zipped(params, range(size(params)))) {
        var name, memberType = ...aggregateMember(llTypeValue, member, i);

        push(llType.dependencies, lowLevelTypeValue(memberType));
        printToIndented(definition, 1, typedefName(c, memberType), " ", mangleString(name), ";\n");
    }

    printlnTo(definition, "};");
}

private codegenUnionType(c, llType, llTypeValue, definition) {
    ref params = llTypeParams(llTypeValue);

    assert(llType.compoundKind == UNION_TYPE, "union type must have UNION_TYPE compound kind");

    printlnTo(definition, llType.preTypeName, " {");

    if (empty?(params) and c.config.dialect == MSVC_DIALECT)
        // XXX this is broken! empty tuple/unions should have size zero!
        // empty types really should be optimized away
        printToIndented(definition, 1, "char _pad_;\n");
    else for (i, member in enumerated(params)) {
        var name, memberType = ...aggregateMember(llTypeValue, member, i);

        push(llType.dependencies, lowLevelTypeValue(memberType));
        printToIndented(definition, 1, typedefName(c, memberType), " ", mangleString(name), ";\n");
    }

    printTo(definition, "};");
}

private cInt64Type(c) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "long long int";
    case MSVC_DIALECT:
        return "__int64";
    default:
        assert(false, "invalid dialect");
        return "";
    }
}

private cIntegerType(c, signed?:Bool, bits) {
    switch (bits) {
    case 8:
        return withSigned(signed?, "char");
    case 16:
        return withSigned(signed?, "short int");
    case 32:
        return withSigned(signed?, "int");
    case 64:
        return withSigned(signed?, cInt64Type(c));
    default:
        genericError("integer type with ", bits, " bits not supported");
        return String();
    }
}

private withSigned(signed?, name) = (if (signed?) "signed " else "unsigned ") + name;

private cFloatType(bits) {
    // XXX assumes IEEE 754 single and double floats
    switch (bits) {
    case 32:
        return String("float");
    case 64:
        return String("double");
    default:
        genericError("float type with ", bits, " bits not supported");
        return String();
    }
}


//
// typedef codegen
//

private typedefAttributes(c, typeValue) {
    var align = typeAlign(typeValue);
    var naturalAlign = typeNaturalAlign(typeValue);
    if (align != naturalAlign) {
        switch (c.config.dialect) {
        case GCC_DIALECT:
            return printString("__attribute__((aligned(", align, "))) ");
        case MSVC_DIALECT:
            return printString("__declspec(align(", align, ")) ");
        default:
            assert(false);
            return String("");
        }
    } else
        return String("");
}

private codegenTypedef(c, typeValue:Value) {
    var llType = getLLType(c, lowLevelTypeValue(typeValue));
    return printString(
        "typedef ",
        typedefAttributes(c, typeValue),
        llType.preTypeName, ' ', mangleType(typeValue), ' ', llType.postTypeName, ';'
    );
}


//
// printCodegenTo
//

printCodegenTo(stream, c:CodegenContext) {
    printCodegenHeaderTo(stream, c);
    printLLTypeForwardDeclarationsTo(stream, c);
    printTypedefsTo(stream, c);
    printLLTypeDefinitionsTo(stream, c);
    printHelperTypeDefinitionsTo(stream, c);
    printGlobalVariablesTo(stream, c);
    printGlobalLiteralCodeBodiesTo(stream, c);
    printConstantDefinitionsTo(stream, c);
    printExternalDeclarationsTo(stream, c);
    printFunctionForwardDeclarationsTo(stream, c);
    printExternalEntryPointsTo(stream, c);
    printFunctionDefinitionsTo(stream, c);
}

private printCodegenHeaderTo(stream, c:CodegenContext) {
    printlnTo(stream, "/* Generated by newclay */");
    printlnTo(stream, "#line 1 \"(clay generated)\"");
    printlnTo(stream);
}

private printLLTypeForwardDeclarationsTo(stream, c:CodegenContext) {
    for (llTypeValue in c.llTypeOrder) {
        ref llType = getLLType(c, llTypeValue);
        if (llType.compoundKind != PRIMITIVE_TYPE)
            printlnTo(stream, llType.preTypeName, ";");
    }
    printlnTo(stream);
}

private printTypedefsTo(stream, c:CodegenContext) {
    for (typeValue in c.typedefOrder) {
        ref typedef = getTypedef(c, typeValue);
        if (not empty?(typedef.definition))
            printlnTo(stream, typedef.definition);
    }
}

private printLLTypeDefinitionsTo(stream, c:CodegenContext) {
    var printedSet = HashMap[Value, Bool]();
    for (llTypeValue in c.llTypeOrder)
        printLLTypeDefinitionTo(stream, c, llTypeValue, printedSet);
}

private printLLTypeDefinitionTo(stream, c, llTypeValue, printedSet) {
    var printedp = lookup(printedSet, llTypeValue);
    if (not null?(printedp)) {
        if (printedp^)
            return;
        else
            genericError("invalid recursive type dependency on ", llTypeValue);
    }
    printedSet[llTypeValue] = false;
    ref llType = getLLType(c, llTypeValue);
    for (dep in llType.dependencies)
        printLLTypeDefinitionTo(stream, c, dep, printedSet);
    if (not empty?(just(llType.definition)))
        printlnTo(stream, just(llType.definition));
    printedSet[llTypeValue] = true;
}

private printHelperTypeDefinitionsTo(stream, c:CodegenContext) {
    printlnTo(stream, "union _clay_Float32Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 32), " asBits;");
    printlnTo(stream, "  ", cFloatType(32), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream, "union _clay_Float64Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 64), " asBits;");
    printlnTo(stream, "  ", cFloatType(64), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream);
}

private printGlobalVariablesTo(stream, c:CodegenContext) {
    ref globalMap = getProgram().globalMap;
    for (g in reversed(globalMap.globalOrder)) {
        printlnTo(stream, "static ", typedefName(c, globalAttributes(g).type), " ", globalName(c, g), ";");
    }
    printlnTo(stream);
}

private printGlobalLiteralCodeBodiesTo(stream, c:CodegenContext) {
    for (codeBody in getProgram().allLiteralCodeBodies) {
        if (codeBody.kind == ast.LITERAL_LLVM)
            genericError("top-level __llvm__ is not yet supported");
        if (codeBody.kind == ast.LITERAL_ASM)
            genericError("top-level __asm__ is not yet supported");
        printGlobalLiteralCodeTo(c, stream, codeBody.code);
        printlnTo(stream);
    }
    printlnTo(stream);
}

private printConstantDefinitionsTo(stream, c) {
    for (value in c.constantOrder) {
        ref constant = c.constants[value];
        printlnTo(stream, constant.definition);
    }
    printlnTo(stream);
}

private printExternalDeclarationsTo(stream, c:CodegenContext) {
    for (symbolName in c.externalOrder)
        printExternalDeclarationTo(stream, c, c.externals[symbolName]);
    printlnTo(stream);
}

private printExternalEntryPointsTo(stream, c:CodegenContext) {
    for (externalKey in c.externalEntryPointOrder)
        printExternalEntryPointTo(stream, c, externalKey);
    printlnTo(stream);
}

private printFunctionForwardDeclarationsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        printlnTo(stream, just(function.signature), ";");
    }
    printlnTo(stream);
}

private printFunctionDefinitionsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        printlnTo(stream, just(function.signature), " {");
        printTo(stream, just(function.definition));
        printlnTo(stream, "}");
    }
    if (c.config.dialect == MSVC_DIALECT)
        printMSVCConstructorDefinitionTo(stream, c);

    printlnTo(stream);
}

private printMSVCConstructorDefinitionTo(stream, c) {
    if (just?(c.constructorFunction) or just?(c.destructorFunction)) {
        printlnTo(stream, "#pragma section(\".CRT$XCU\",read)");
        maybe(c.destructorFunction, desS ref=> {
            printlnTo(stream, "typedef int (*_onexit_t)(void);");
            printlnTo(stream, "_onexit_t _onexit(_onexit_t);");
            printlnTo(stream, "static int _clay_msvc_destructor(void) {");
            printlnTo(stream, "  ", functionName(c, desS), "();");
            printlnTo(stream, "  return 0;");
            printlnTo(stream, "}");
        });
        printlnTo(stream, "static void _clay_msvc_constructor(void) {");
        maybe(c.constructorFunction, consS ref=> {
            printlnTo(stream, "  ", functionName(c, consS), "();");
        });
        maybe(c.destructorFunction, desS ref=> {
            printlnTo(stream, "  _onexit(_clay_msvc_destructor);");
        });
        printlnTo(stream, "}");
        printlnTo(stream, "__declspec(allocate(\".CRT$XCU\")) void (*_clay_msvc_constructor_ptr)(void) = _clay_msvc_constructor;");
    }
}



//
// print*FunctionTypeTo, printExternalDeclarationTo
//

private functionABI(c, abi) {
    if (abi == getHooks().CdeclABI)
        return String();
    else if (abi == getHooks().StdcallABI)
        return functionABI2(c, "stdcall");
    else {
        genericError("unsupported ABI value ", abi);
        return String();
    }
}

private functionABI2(c, name) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "__attribute__((" + name + ")) ";
    case MSVC_DIALECT:
        return "__" + name + " ";
    default:
        assert(false, "invalid dialect");
        return String();
    }
}

private printPreFunctionTypeTo(stream, c, pointer?, abi, variadic?, inputTypes, outputType) {
    var returnTypeName = maybe(outputType,
        type ref=> typedefName(c, type),
        ()   ref=> String("void"),
    );
    printTo(stream, returnTypeName, ' ');
    if (pointer?)
        printTo(stream, '(');
    printTo(stream, functionABI(c, abi));
    if (pointer?)
        printTo(stream, '*');
}

private printPostFunctionTypeTo(stream, c, pointer?, abi, variadic?, inputTypes, outputType) {
    if (pointer?)
        printTo(stream, ')');
    printTo(stream, '(');

    if (empty?(inputTypes))
        printTo(stream, if (variadic?) "" else "void");
    else {
        interleave(inputTypes,
            () ref=> { printTo(stream, ", "); },
            inputType ref=> {
                printTo(stream, typedefName(c, inputType));
            },
        );
        if (variadic?)
            printTo(stream, ", ...");
    }

    printTo(stream, ")");
}

private printPostFunctionTypeWithNamesTo(stream, c, pointer?, abi, variadic?, inputTypes, inputNames, outputType) {
    if (pointer?)
        printTo(stream, ')');
    printTo(stream, '(');

    if (empty?(inputTypes))
        printTo(stream, if (variadic?) "" else "void");
    else {
        interleave(zipped(inputTypes, inputNames),
            () ref=> { printTo(stream, ", "); },
            (inputType, inputName) ref=> {
                printTo(stream, typedefName(c, inputType), " ", inputName);
            },
        );
        if (variadic?)
            printTo(stream, ", ...");
    }

    printTo(stream, ")");
}

private printExternalDeclarationTo(stream, c:CodegenContext, ex:RTExternal) {
    ref attributes = externalAttributes(ex);

    printPreFunctionTypeTo(stream, c, false,
        attributes.abi,
        attributes.variadic?,
        attributes.argumentTypes,
        attributes.returnType,
    );
    printTo(stream, attributes.symbolName);
    printPostFunctionTypeTo(stream, c, false,
        attributes.abi,
        attributes.variadic?,
        attributes.argumentTypes,
        attributes.returnType,
    );

    printlnTo(stream, ";");
}

private printExternalEntryPointTo(stream, c:CodegenContext, key:CodegenExternalEntryPointKey) {
    var name = externalEntryPointName(c, key.specialization, key.type);
    var abi = externalCodePointerABI(key.type);
    var variadic? = false;
    var inputs = externalCodePointerInputTypes(key.type);
    var output = externalCodePointerOutputType(key.type);

    var inputNames = map((i, x) => printString("arg", i), enumerated(inputs));

    printPreFunctionTypeTo(stream, c, false, abi, variadic?, inputs, output);
    printTo(stream, name);
    printPostFunctionTypeWithNamesTo(stream, c, false, abi, variadic?, inputs, inputNames, output);

    printlnTo(stream, " {");

    maybe(output,
        outType ref=> {
            printlnTo(stream, "  ", typedefName(c, outType), " returned;");
            printTo(stream, "  ", functionName(c, key.specialization), "(");
            for (inputName in inputNames)
                printTo(stream, "&", inputName, ", ");
            printlnTo(stream, "&returned);");
            printlnTo(stream, "  return returned;");
        },
        () ref=> {
            printTo(stream, "  ", functionName(c, key.specialization), "(");
            interleave(inputNames,
                () ref=> { printTo(stream, ", "); },
                inputName ref=> { printTo(stream, "&", inputName); },
            );
            printlnTo(stream, ");");
        },
    );

    printlnTo(stream, "}");
}

//
// printGlobalLiteralCodeTo, printLiteralCodeTo
//

private printGlobalLiteralCodeTo(c, stream, code:ir.LiteralCode) {
    for (token in code) {
        match(token,
            String,      s ref=> { printTo(stream, s); },
            RTValue,     v ref=> {
                genericError("invalid global literal code substitution value: ", v);
            },
            RTValueList, m ref=> {
                genericError("invalid global literal code substitution value: ", m);
            },
            Value,       v ref=> { printLiteralCodeValueTo(c, stream, *v); },
            ValueList,   m ref=> { printLiteralCodeValueListTo(c, stream, m); },
        );
    }
}

private printLiteralCodeTo(c, bc, code:ir.LiteralCode) {
    for (token in code) {
        match(token,
            String,      s ref=> { printTo(bc.bodyCode, s); },
            RTValue,     v ref=> { printLiteralCodeRTValueTo(c, bc, v); },
            Value,       v ref=> { printLiteralCodeValueTo(c, bc.bodyCode, *v); },
            RTValueList, m ref=> { printLiteralCodeRTValueListTo(c, bc, m); },
            ValueList,   m ref=> { printLiteralCodeValueListTo(c, bc.bodyCode, m); },
        );
    }
}

private printLiteralCodeRTValueListTo(c, bc, values:RTValueList) {
    interleave(values.vars,
        () ref=> { printTo(bc.bodyCode, ", "); },
        v  ref=> { printLiteralCodeRTValueTo(c, bc, v); },
    );
}

private printLiteralCodeValueListTo(c, stream, values:ValueList) {
    interleave(values,
        () ref=> { printTo(stream, ", "); },
        v  ref=> { printLiteralCodeValueTo(c, stream, v); },
    );
}

private printLiteralCodeRTValueTo(c, bc, v) {
    printTo(bc.bodyCode, '(', valueDeref(c, bc, v), ')');
}

private procedure printLiteralCodeValueTo;

overload printLiteralCodeValueTo(c, stream, x) {
    genericError("invalid literal code substitution value: ", x);
}
overload printLiteralCodeValueTo(c, stream, v:Value)       { printLiteralCodeValueTo(c, stream, *v); }
overload printLiteralCodeValueTo(c, stream, i:IntValue)    { printTo(stream, Int64(i)); }
overload printLiteralCodeValueTo(c, stream, s:StringValue) { printTo(stream, s.value); }
overload printLiteralCodeValueTo(c, stream, ch:CharValue)  { printTo(stream, Int(ch.value)); }
overload printLiteralCodeValueTo(c, stream, b:BoolValue)   { printTo(stream, if (b.value) 1 else 0); }
overload printLiteralCodeValueTo(c, stream, s:Symbol) {
    printTo(stream, typedefName(c, Value(s)));
}



//
// codegenFromEntryPoints
//

codegenFromEntryPoints(config:CodegenConfig, entryPoints:Vector[Specialization]) {
    var c = CodegenContext(config);

    codegenFunctionsToFixedPoint(c, entryPoints);
    codegenGlobalConstructorDestructor(c);
    codegenTypesToFixedPoint(c);

    return move(c);
}

private functionsNeedingCodegen(c) = filter(
    s ref=> nothing?(c.functions[s].definition),
    c.functionOrder
);

private codegenFunctionsToFixedPoint(c, entryPoints) {
    var functionsToCodegen = entryPoints;
    while (not empty?(functionsToCodegen)) {
        for (s in functionsToCodegen)
            analyzeAndCodegenFunction(c, s);

        var oldFunctionsToCodegen = move(functionsToCodegen);
        functionsToCodegen = functionsNeedingCodegen(c); 
        if (oldFunctionsToCodegen == functionsToCodegen)
            genericError("unable to propagate all functions");
    }
}

private codegenTypesToFixedPoint(c) {
    var llTypesToCodegen = c.llTypeOrder;
    while (not empty?(llTypesToCodegen)) {
        for (t in llTypesToCodegen)
            codegenLLType(c, t);

        var oldLLTypesToCodegen = move(llTypesToCodegen);
        llTypesToCodegen = filter(
            t ref=> nothing?(c.llTypes[t].definition),
            c.llTypeOrder,
        );

        if (oldLLTypesToCodegen == llTypesToCodegen)
            genericError("unable to generate all types");
    }
}

private analyzeAndCodegenFunction(c:CodegenContext, s:Specialization) {
    if (nothing?(s.body))
        if (not analyzeCallableBody(s)) {
            getFunction(c, s); // add to function list and try again later
            return;
        }
    optimizeSpecialization(s);
    lifetimeAnalyzeSpecialization(s);
    codegenFunction(c, s);
}

private codegenGlobalConstructorDestructor(c:CodegenContext) {
    for (g in getProgram().globalMap.globalOrder) {
        getTypedef(c, globalAttributes(g).type);
    }

    maybe(analyzeGlobalConstructor(), constructorS ref=> {
        addFunction(c, constructorS);
        c.constructorFunction = Maybe(constructorS);
        analyzeAndCodegenFunction(c, constructorS);
    });
    maybe(lifetimeAnalyzeGlobalDestructor(), destructorS ref=> {
        addFunction(c, destructorS);
        c.destructorFunction = Maybe(destructorS);
        analyzeAndCodegenFunction(c, destructorS);
    });
    codegenFunctionsToFixedPoint(c, functionsNeedingCodegen(c));
}

//
// codegenStandaloneProgramTo
//

private printStandaloneStubTo(stream, c, mainS) {
    printlnTo(stream);
    printlnTo(stream, "#line 1 \"(clay generated)\"");
    printlnTo(stream, "int main(int _argc, char **_argv) {");
    printlnTo(stream, "  ", typedefName(c, intType()), " argc = (", typedefName(c, intType()), ")_argc;");
    printlnTo(stream, "  ", typedefName(c, pointerType(pointerType(int8Type()))), " argv = (", typedefName(c, pointerType(pointerType(int8Type()))), ")_argv;");
    if (nothing?(mainS.results)) {
        printlnTo(stream, "  ", functionName(c, mainS), "(&argc, &argv);");
        printlnTo(stream, "  /* main does not return */");
        printlnTo(stream, "  return 0;");
    } else {
        printlnTo(stream, "  ", typedefName(c, intType()), " exitCode;");
        printlnTo(stream, "  ", functionName(c, mainS), "(&argc, &argv, &exitCode);");
        printlnTo(stream, "  return (int)exitCode;");
    }
    printlnTo(stream, "}");
}

codegenStandaloneProgramTo(config:CodegenConfig, stream) {
    var mainS = analyzeCallable(getHooks().callMain, RTValues(
        RTValue(RT_VALUE_REF, intType()),
        RTValue(RT_VALUE_REF, pointerType(pointerType(int8Type())))
    ));

    var mainResultsOk? = maybe(mainS.results,
        results => size(results) == 1 and results[0].type == intType(),
        () => true
    );

    if (not mainResultsOk?)
        genericError("callMain(Int, Pointer[Pointer[Int8]]) must return an Int but returns ", mainS.results);

    var c = codegenFromEntryPoints(config, Vector[Specialization](mainS));
    printCodegenTo(stream, c);
    printStandaloneStubTo(stream, c, mainS);
}

